const a=a=>typeof a,t="tinybase",e="",n=",",s=a(e),i=Promise,r=clearInterval,o=a=>null==a,c=(a,t,e)=>o(a)?e?.():t(a),l=t=>a(t)==s,E=a=>Array.isArray(a),w=(a,t,e)=>a.slice(t,e),y=a=>a.length,d=async a=>i.all(a),u=a=>{throw Error(a)},R=(a,t)=>a.forEach(t),A=(a,t="")=>a.join(t),T=(a,t)=>a.map(t),N=a=>0==y(a),g=(a,t)=>a.filter(t),O=(a,...t)=>a.push(...t),$=a=>a.shift(),p=Object,m=a=>p.getPrototypeOf(a),v=p.entries,C=p.keys,L=p.freeze,I=(a=[])=>p.fromEntries(a),S=(...a)=>p.assign({},...a),_=(a,t)=>(delete a[t],a),h=(a,t)=>T(v(a),(([a,e])=>t(e,a))),b=a=>p.values(a),f=a=>y(C(a)),D=a=>(a=>!o(a)&&c(m(a),(a=>a==p.prototype||o(m(a))),(()=>!0)))(a)&&0==f(a),M=(a,t)=>a?.has(t)??!1,P=a=>o(a)||0==(a=>a?.size??0)(a),F=a=>[...a?.values()??[]],U=(a,t)=>a?.forEach(t),G=(a,t)=>a?.delete(t),B=a=>new Map(a),j=(a,t)=>a?.get(t),Y=(a,t)=>T([...a?.entries()??[]],(([a,e])=>t(e,a))),x=(a,t,e)=>o(e)?(G(a,t),a):a?.set(t,e),H=(a,t,e,n)=>(M(a,t)?n?.(j(a,t)):x(a,t,e()),j(a,t)),X=(a,t,e,n,s=0)=>c((e?H:j)(a,t[s],s>y(t)-2?e:B),(i=>{if(s>y(t)-2)return n?.(i)&&x(a,t[s]),i;const r=X(i,t,e,n,s+1);return P(i)&&x(a,t[s]),r})),J=a=>new Set(E(a)||o(a)?a:[a]),W=(a,t)=>a?.add(t),k=/^\d+$/,q={Idle:0,Loading:1,Saving:2},z={StoreOnly:1,MergeableStoreOnly:2,StoreOrMergeableStore:3},K=B(),V=B(),Q=(a,t,n,s,i,r,l,w={},d=0,A=[])=>{let T,N,g,p=0,m=0,v=0;H(K,A,(()=>0)),H(V,A,(()=>[]));const C=B(),[I,S,_,h,b]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!D(a)||!D(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!D(a)||!D(t),t.setContent]:u("Store type not supported by this Persister"))(l,a,d),[f,M,F]=(()=>{let a;const[t,n]=(()=>{const a=[];let t=0;return[n=>(n?$(a):null)??e+t++,t=>{k.test(t)&&y(a)<1e3&&O(a,t)}]})(),s=B();return[(n,i,r,o=[],c=()=>[])=>{a??=ea;const l=t(1);return x(s,l,[n,i,r,o,c]),W(X(i,r??[e],J),l),l},(t,n,...i)=>R(((a,t=[e])=>{const n=[],s=(a,e)=>e==y(t)?O(n,a):null===t[e]?U(a,(a=>s(a,e+1))):R([t[e],null],(t=>s(j(a,t),e+1)));return s(a,0),n})(t,n),(t=>U(t,(t=>j(s,t)[0](a,...n??[],...i))))),a=>c(j(s,a),(([,t,i])=>(X(t,i??[e],void 0,(t=>(G(t,a),P(t)?1:0))),x(s,a),n(a),i))),t=>c(j(s,t),(([t,,e=[],n,s])=>{const i=(...r)=>{const c=y(r);c==y(e)?t(a,...r,...s(r)):o(e[c])?R(n[c]?.(...r)??[],(a=>i(...r,a))):i(...r,e[c])};i()}))]})(),Y=a=>{a!=p&&(p=a,M(C,void 0,p))},q=t=>{(I&&E(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},z=async a=>(2!=p&&(Y(1),m++,await ta((async()=>{try{const e=await t();E(e)?q(e):a?b(a):u("Content is not an array: "+e)}catch(t){r?.(t),a&&b(a)}Y(0)}))),ea),Q=()=>(N&&(i(N),N=void 0),ea),Z=async a=>(1!=p&&(Y(2),v++,await ta((async()=>{try{await n(S,a)}catch(a){r?.(a)}Y(0)}))),ea),aa=()=>(g&&(a.delListener(g),g=void 0),ea),ta=async(...a)=>(O(j(V,A),...a),await(async()=>{if(!j(K,A)){for(x(K,A,1);!o(T=$(j(V,A)));)try{await T()}catch(a){r?.(a)}x(K,A,0)}})(),ea),ea={load:z,startAutoLoad:async a=>{Q(),await z(a);try{N=await s((async(a,t)=>{t||a?2!=p&&(Y(1),m++,q(t??a),Y(0)):await z()}))}catch(a){r?.(a)}return ea},stopAutoLoad:Q,isAutoLoading:()=>!o(N),save:Z,startAutoSave:async()=>(aa(),await Z(),g=a.addDidFinishTransactionListener((()=>{const a=_();h(a)&&Z(a)})),ea),stopAutoSave:aa,isAutoSaving:()=>!o(g),getStatus:()=>p,addStatusListener:a=>f(a,C),delListener:t=>(F(t),a),schedule:ta,getStore:()=>a,destroy:()=>(j(V,A).splice(0,void 0),Q().stopAutoSave()),getStats:()=>({loads:m,saves:v}),...w};return L(ea)},Z="_",aa="_id",ta="SELECT",ea="WHERE",na="TABLE",sa="ALTER "+na,ia="DELETE FROM",ra=ta+"*FROM",oa="pragma_",ca="data_version",la="schema_version",Ea="pragma_table_",wa=(a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a,ya=a=>`"${a.replace(/"/g,'""')}"`,da=(a,t=[1])=>A(T(a,(()=>"$"+t[0]++)),n),ua=JSON.stringify,Ra=JSON.parse,Aa=(a,t,e,s,i,r=Ta,c,l)=>{const E=B();return[async()=>{E.clear(),T(await e(a,t),(({tn:a,cn:t})=>W(H(E,a,J),t)))},async(t,e)=>((a,t)=>M(j(E,a),t))(t,e)?I(g(T(await a(ra+ya(t)),(a=>{return[a[e],l?(t=_(a,e),n=l,I(h(t,((a,t)=>[t,n(a,t)])))):_(a,e)];var t,n})),(([a,t])=>!o(a)&&!D(t)))):{},async(t,e,s,l,w,y=!1)=>{const u=J();h(s??{},(a=>T(C(a??{}),(a=>W(u,a)))));const R=F(u);if(!y&&w&&N(R)&&M(E,t))return await a("DROP "+na+ya(t)),void x(E,t);const $=j(E,t),p=J(F($));if(N(R)||(M(E,t)?await d(T([e,...R],(async(n,s)=>{G(p,n)||(await a(sa+ya(t)+"ADD"+ya(n)+i),0==s&&await a("CREATE UNIQUE INDEX pk ON "+ya(t)+`(${ya(e)})`),W($,n))}))):(await a("CREATE "+na+ya(t)+`(${ya(e)}${i} PRIMARY KEY${A(T(R,(a=>n+ya(a)+i)))});`),x(E,t,J([e,...R])))),await d([...!y&&l?T(F(p),(async n=>{n!=e&&(await a(sa+ya(t)+"DROP"+ya(n)),G($,n))})):[]]),y)o(s)?await a(ia+ya(t)+ea+" true"):await d(h(s,(async(n,s)=>{o(n)?await a(ia+ya(t)+ea+ya(e)+"=$1",[s]):N(R)||await r(a,t,e,C(n),{[s]:c?T(b(n),c):b(n)},$)})));else if(N(R))M(E,t)&&await a(ia+ya(t)+ea+" true");else{const n=g(F(j(E,t)),(a=>a!=e)),i={},o=[];h(s??{},((a,t)=>{i[t]=T(n,(t=>c?c(a?.[t]):a?.[t])),O(o,t)})),await r(a,t,e,n,i),await a(ia+ya(t)+ea+ya(e)+`NOT IN(${da(o)})`,o)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){s?.(a)}return await a("END"),e}]},Ta=async(a,t,e,s,i)=>{const r=[1];await a("INSERT INTO"+ya(t)+"("+((...a)=>A(T(a,ya),n))(e,...s)+")VALUES"+A(h(i,(a=>"($"+r[0]+++","+da(a,r)+")")),n)+"ON CONFLICT("+ya(e)+")DO UPDATE SET"+A(T(s,(a=>ya(a)+"=excluded."+ya(a))),n),h(i,((a,t)=>[t,...T(a,(a=>a??null))])).flat())},Na=(a,t,e,n,s,i,r,[o,c,l],E,w,y,d,u,R)=>{const[A,T,N,g]=Aa(t,E,w,s,u,R),O=Q(a,(async()=>await g((async()=>{return await A(),a=(await T(o,c))[Z]?.[l]??"null",Ra(a,((a,t)=>"ï¿¼"===t?void 0:t));var a}))),(async a=>await g((async()=>{var t;await A(),await N(o,c,{[Z]:{[l]:(t=a()??null,ua(t,((a,t)=>void 0===t?"ï¿¼":t)))}},!0,!0)}))),e,n,s,r,{[d]:()=>y,destroy:()=>(O.stopAutoLoad().stopAutoSave(),i(),O)},0,y);return O},ga=(a,t,e,n,s,i,r,[c,l,[E,w,y]],u,R,A,T,N,O,$,p)=>{const[m,v,C,L]=Aa(t,u,R,s,N,O,$,p),S=async(a,t)=>await d(Y(l,(async([e,n,s,i],r)=>{t&&!(r in a)||await C(e,n,a[r],s,i,t)}))),_=async(a,t)=>w?await C(y,aa,{[Z]:a},!0,!0,t):null,h=Q(a,(async()=>await L((async()=>{await m();const a=await(async()=>I(g(await d(Y(c,(async([a,t],e)=>[a,await v(e,t)]))),(a=>!D(a[1])))))(),t=await(async()=>E?(await v(y,aa))[Z]:{})();return D(a)&&o(t)?void 0:[a,t]}))),(async(a,t)=>await L((async()=>{if(await m(),o(t)){const[t,e]=a();await S(t),await _(e)}else await S(t[0],!0),await _(t[1],!0)}))),e,n,s,r,{[T]:()=>A,destroy:()=>(h.stopAutoLoad().stopAutoSave(),i(),h)},0,A);return h},Oa="ColumnName",$a="store",pa="json",ma=$a+"TableName",va=$a+"Id"+Oa,Ca=$a+Oa,La="autoLoadIntervalSeconds",Ia="rowId"+Oa,Sa="tableId",_a="tableName",ha="deleteEmptyColumns",ba="deleteEmptyTable",fa={mode:pa,[La]:1},Da={load:0,save:0,[_a]:t+"_values"},Ma=(a,t,e,n,s)=>{const i=B();return h(a,((a,r)=>{const c=w(b(S(t,l(a)?{[e]:a}:a)),0,f(t));o(c[0])||n(r,c[0])||(s(r,c[0]),x(i,r,c))})),i},Pa=a=>{const e=(a=>S(fa,l(a)?{[ma]:a}:a??{}))(a),n=e[La];if(e.mode==pa){const a=e[ma]??t;return[1,n,[a,e[va]??aa,e[Ca]??$a],J(a)]}const{tables:{load:s={},save:i={}}={},values:r={}}=e,o=w(b(S(Da,r)),0,f(Da)),c=o[2],E=J(c),y=J(c);return[0,n,[Ma(s,{[Sa]:null,[Ia]:aa},Sa,(a=>M(y,a)),(a=>W(E,a))),Ma(i,{[_a]:null,[Ia]:aa,[ha]:0,[ba]:0},_a,((a,t)=>M(y,t)),((a,t)=>W(E,t))),o],E]},Fa=(a,t,n,s,i,o,c,l,E,w,y="getDb",d)=>{let u,R,A;const T=wa(n,o),[N,g,O,$]=Pa(t);return(N?Na:ga)(a,T,(a=>{let t;const e=()=>t=setInterval((async()=>{try{const[{d:t,s:e,c:n}]=await T(`${ta} ${ca} d,${la} s,TOTAL_CHANGES() c FROM ${oa}${ca} JOIN ${oa}${la}`);t==u&&e==R&&n==A||(null!=u&&a(),u=t,R=e,A=n)}catch{}}),1e3*g),n=()=>{u=R=A=null,r(t)},o=s((t=>{$.has(t)&&(n(),a(),e())}));return e(),()=>{n(),i(o)}}),(a=>a()),c,l,E,O,F($),(async(a,t)=>await a(`${ta} t.name tn,c.name cn FROM ${Ea}list()t,${Ea}info(t.name)c ${ea} t.schema='main'AND t.type IN('table','view')AND t.name IN(${da(t)})ORDER BY t.name,c.name`,t)),w,y,e,d,(a=>!0===a?1:!1===a?0:a),void 0)},Ua=t,Ga=/^([cd]:)(.+)/,Ba=t+"_data",ja=t+"_table",Ya=(a,t,e,n,s,i,r,o,l,E,w="getDb")=>{const y=wa(e,i),[u,,R,A]=Pa(t),N=async a=>{await y(`CREATE OR REPLACE TRIGGER ${ya(Ba+"_"+a)} AFTER INSERT OR UPDATE OR DELETE ON ${ya(a)} EXECUTE FUNCTION ${Ba}()`)};return(u?Na:ga)(a,y,(async a=>{await y(`CREATE OR REPLACE FUNCTION ${ja}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${Ua}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await y(`CREATE EVENT TRIGGER ${ja} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${ja}();`)}catch{}return await y(`CREATE OR REPLACE FUNCTION ${Ba}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${Ua}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await d(T(F(A),(async a=>{await y(`CREATE TABLE IF NOT EXISTS ${ya(a)}("_id"text PRIMARY KEY)`),await N(a)}))),await n(Ua,(async t=>{return await c((e=t,n=Ga,e?.match(n)),(async([,t,e])=>{M(A,e)&&("c:"==t&&await N(e),a())}));var e,n}))}),s,r,o,l,R,F(A),(async(a,t)=>await a(`${ta} table_name tn,column_name cn FROM information_schema.columns ${ea} table_schema='public'AND table_name IN(${da(t)})`,t)),E,w,"text",void 0,(a=>ua(a)),(a=>Ra(a)))};export{z as Persists,q as Status,Q as createCustomPersister,Ya as createCustomPostgreSqlPersister,Fa as createCustomSqlitePersister};
