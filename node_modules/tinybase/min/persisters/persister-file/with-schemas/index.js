import{existsSync as t,writeFileSync as e,watch as a}from"fs";import{readFile as s,writeFile as n}from"fs/promises";const r="utf8",o=t=>null==t,i=(t,e,a)=>o(t)?a?.():e(t),c=t=>Array.isArray(t),l=t=>t.length,u=t=>{throw Error(t)},y=(t,e)=>t.forEach(e),d=(t,...e)=>t.push(...e),g=t=>t.shift(),p=Object,h=t=>p.getPrototypeOf(t),v=p.keys,f=p.freeze,w=t=>(t=>!o(t)&&i(h(t),(t=>t==p.prototype||o(h(t))),(()=>!0)))(t)&&0==(t=>l(v(t)))(t),S=JSON.stringify,C=JSON.parse,A=t=>o(t)||0==(t=>t?.size??0)(t),b=(t,e)=>t?.forEach(e),L=(t,e)=>t?.delete(e),M=t=>new Map(t),m=(t,e)=>t?.get(e),O=(t,e,a)=>o(a)?(L(t,e),t):t?.set(e,a),E=(t,e,a,s)=>{var n,r;return n=t,r=e,n?.has(r)?s?.(m(t,e)):O(t,e,a()),m(t,e)},P=(t,e,a,s,n=0)=>i((a?E:m)(t,e[n],n>l(e)-2?a:M),(r=>{if(n>l(e)-2)return s?.(r)&&O(t,e[n]),r;const o=P(r,e,a,s,n+1);return A(r)&&O(t,e[n]),o})),T=t=>new Set(c(t)||o(t)?t:[t]),z=/^\d+$/,D=M(),F=M(),J=(t,e,a,s,n,r,p,h={},v=0,S=[])=>{let C,J,N,j=0,k=0,x=0;E(D,S,(()=>0)),E(F,S,(()=>[]));const $=M(),[q,B,G,H,I]=((t=1,e,a)=>1!=t&&e.isMergeable()?[1,e.getMergeableContent,()=>e.getTransactionMergeableChanges(!a),([[t],[e]])=>!w(t)||!w(e),e.setDefaultContent]:2!=t?[0,e.getContent,e.getTransactionChanges,([t,e])=>!w(t)||!w(e),e.setContent]:u("Store type not supported by this Persister"))(p,t,v),[K,Q,R]=(()=>{let t;const[e,a]=(()=>{const t=[];let e=0;return[a=>(a?g(t):null)??""+e++,e=>{z.test(e)&&l(t)<1e3&&d(t,e)}]})(),s=M();return[(a,n,r,o=[],i=()=>[])=>{t??=tt;const c=e(1);var l,u;return O(s,c,[a,n,r,o,i]),l=P(n,r??[""],T),u=c,l?.add(u),c},(e,a,...n)=>y(((t,e=[""])=>{const a=[],s=(t,n)=>n==l(e)?d(a,t):null===e[n]?b(t,(t=>s(t,n+1))):y([e[n],null],(e=>s(m(t,e),n+1)));return s(t,0),a})(e,a),(e=>b(e,(e=>m(s,e)[0](t,...a??[],...n))))),t=>i(m(s,t),(([,e,n])=>(P(e,n??[""],void 0,(e=>(L(e,t),A(e)?1:0))),O(s,t),a(t),n))),e=>i(m(s,e),(([e,,a=[],s,n])=>{const r=(...i)=>{const c=l(i);c==l(a)?e(t,...i,...n(i)):o(a[c])?y(s[c]?.(...i)??[],(t=>r(...i,t))):r(...i,a[c])};r()}))]})(),U=t=>{t!=j&&(j=t,Q($,void 0,j))},V=e=>{(q&&c(e?.[0])?1===e?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===e?.[2]?t.applyChanges:t.setContent)(e)},W=async t=>(2!=j&&(U(1),k++,await _((async()=>{try{const a=await e();c(a)?V(a):t?I(t):u("Content is not an array: "+a)}catch(e){r?.(e),t&&I(t)}U(0)}))),tt),X=()=>(J&&(n(J),J=void 0),tt),Y=async t=>(1!=j&&(U(2),x++,await _((async()=>{try{await a(B,t)}catch(t){r?.(t)}U(0)}))),tt),Z=()=>(N&&(t.delListener(N),N=void 0),tt),_=async(...t)=>(d(m(F,S),...t),await(async()=>{if(!m(D,S)){for(O(D,S,1);!o(C=g(m(F,S)));)try{await C()}catch(t){r?.(t)}O(D,S,0)}})(),tt),tt={load:W,startAutoLoad:async t=>{X(),await W(t);try{J=await s((async(t,e)=>{e||t?2!=j&&(U(1),k++,V(e??t),U(0)):await W()}))}catch(t){r?.(t)}return tt},stopAutoLoad:X,isAutoLoading:()=>!o(J),save:Y,startAutoSave:async()=>(Z(),await Y(),N=t.addDidFinishTransactionListener((()=>{const t=G();H(t)&&Y(t)})),tt),stopAutoSave:Z,isAutoSaving:()=>!o(N),getStatus:()=>j,addStatusListener:t=>K(t,$),delListener:e=>(R(e),t),schedule:_,getStore:()=>t,destroy:()=>(m(F,S).splice(0,void 0),X().stopAutoSave()),getStats:()=>({loads:k,saves:x}),...h};return f(tt)},N=(o,i,c)=>J(o,(async()=>{return t=await s(i,r),C(t,((t,e)=>"￼"===e?void 0:e));var t}),(async t=>{return await n(i,(e=t(),S(e,((t,e)=>void 0===e?"￼":e))),r);var e}),(s=>(t(i)||e(i,"",r),a(i,(()=>s())))),(t=>t?.close()),c,3,{getFilePath:()=>i});export{N as createFilePersister};
