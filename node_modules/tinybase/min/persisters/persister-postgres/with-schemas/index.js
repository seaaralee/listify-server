const a=a=>typeof a,t="tinybase",e=",",n=a(""),s=Promise,i=a=>null==a,r=(a,t,e)=>i(a)?e?.():t(a),o=t=>a(t)==n,c=a=>Array.isArray(a),E=(a,t,e)=>a.slice(t,e),l=a=>a.length,w=async a=>s.all(a),y=a=>{throw Error(a)},u=(a,t)=>a.forEach(t),d=(a,t="")=>a.join(t),T=(a,t)=>a.map(t),R=a=>0==l(a),A=(a,t)=>a.filter(t),N=(a,...t)=>a.push(...t),g=a=>a.shift(),p="_",C="_id",O="SELECT",L="WHERE",v="TABLE",$="ALTER "+v,S="DELETE FROM",I=O+"*FROM",m=a=>`"${a.replace(/"/g,'""')}"`,_=(a,t=[1])=>d(T(a,(()=>"$"+t[0]++)),e),h=(a,t)=>a?.has(t)??!1,f=a=>i(a)||0==(a=>a?.size??0)(a),b=a=>[...a?.values()??[]],D=(a,t)=>a?.forEach(t),P=(a,t)=>a?.delete(t),U=Object,F=a=>U.getPrototypeOf(a),M=U.entries,G=U.keys,B=U.freeze,j=(a=[])=>U.fromEntries(a),x=(...a)=>U.assign({},...a),X=(a,t)=>(delete a[t],a),Y=(a,t)=>T(M(a),(([a,e])=>t(e,a))),q=a=>U.values(a),H=a=>l(G(a)),W=a=>(a=>!i(a)&&r(F(a),(a=>a==U.prototype||i(F(a))),(()=>!0)))(a)&&0==H(a),k=JSON.stringify,z=JSON.parse,J=a=>new Map(a),K=(a,t)=>a?.get(t),V=(a,t)=>T([...a?.entries()??[]],(([a,e])=>t(e,a))),Q=(a,t,e)=>i(e)?(P(a,t),a):a?.set(t,e),Z=(a,t,e,n)=>(h(a,t)?n?.(K(a,t)):Q(a,t,e()),K(a,t)),aa=(a,t,e,n,s=0)=>r((e?Z:K)(a,t[s],s>l(t)-2?e:J),(i=>{if(s>l(t)-2)return n?.(i)&&Q(a,t[s]),i;const r=aa(i,t,e,n,s+1);return f(i)&&Q(a,t[s]),r})),ta=a=>new Set(c(a)||i(a)?a:[a]),ea=(a,t)=>a?.add(t),na=/^\d+$/,sa=J(),ia=J(),ra=(a,t,e,n,s,o,E,w={},d=0,T=[])=>{let R,A,p,C=0,O=0,L=0;Z(sa,T,(()=>0)),Z(ia,T,(()=>[]));const v=J(),[$,S,I,m,_]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!W(a)||!W(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!W(a)||!W(t),t.setContent]:y("Store type not supported by this Persister"))(E,a,d),[h,b,U]=(()=>{let a;const[t,e]=(()=>{const a=[];let t=0;return[e=>(e?g(a):null)??""+t++,t=>{na.test(t)&&l(a)<1e3&&N(a,t)}]})(),n=J();return[(e,s,i,r=[],o=()=>[])=>{a??=q;const c=t(1);return Q(n,c,[e,s,i,r,o]),ea(aa(s,i??[""],ta),c),c},(t,e,...s)=>u(((a,t=[""])=>{const e=[],n=(a,s)=>s==l(t)?N(e,a):null===t[s]?D(a,(a=>n(a,s+1))):u([t[s],null],(t=>n(K(a,t),s+1)));return n(a,0),e})(t,e),(t=>D(t,(t=>K(n,t)[0](a,...e??[],...s))))),a=>r(K(n,a),(([,t,s])=>(aa(t,s??[""],void 0,(t=>(P(t,a),f(t)?1:0))),Q(n,a),e(a),s))),t=>r(K(n,t),(([t,,e=[],n,s])=>{const r=(...o)=>{const c=l(o);c==l(e)?t(a,...o,...s(o)):i(e[c])?u(n[c]?.(...o)??[],(a=>r(...o,a))):r(...o,e[c])};r()}))]})(),F=a=>{a!=C&&(C=a,b(v,void 0,C))},M=t=>{($&&c(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},G=async a=>(2!=C&&(F(1),O++,await Y((async()=>{try{const e=await t();c(e)?M(e):a?_(a):y("Content is not an array: "+e)}catch(t){o?.(t),a&&_(a)}F(0)}))),q),j=()=>(A&&(s(A),A=void 0),q),x=async a=>(1!=C&&(F(2),L++,await Y((async()=>{try{await e(S,a)}catch(a){o?.(a)}F(0)}))),q),X=()=>(p&&(a.delListener(p),p=void 0),q),Y=async(...a)=>(N(K(ia,T),...a),await(async()=>{if(!K(sa,T)){for(Q(sa,T,1);!i(R=g(K(ia,T)));)try{await R()}catch(a){o?.(a)}Q(sa,T,0)}})(),q),q={load:G,startAutoLoad:async a=>{j(),await G(a);try{A=await n((async(a,t)=>{t||a?2!=C&&(F(1),O++,M(t??a),F(0)):await G()}))}catch(a){o?.(a)}return q},stopAutoLoad:j,isAutoLoading:()=>!i(A),save:x,startAutoSave:async()=>(X(),await x(),p=a.addDidFinishTransactionListener((()=>{const a=I();m(a)&&x(a)})),q),stopAutoSave:X,isAutoSaving:()=>!i(p),getStatus:()=>C,addStatusListener:a=>h(a,v),delListener:t=>(U(t),a),schedule:Y,getStore:()=>a,destroy:()=>(K(ia,T).splice(0,void 0),j().stopAutoSave()),getStats:()=>({loads:O,saves:L}),...w};return B(q)},oa=(a,t,n,s,r,o=ca,c,E)=>{const l=J();return[async()=>{l.clear(),T(await n(a,t),(({tn:a,cn:t})=>ea(Z(l,a,ta),t)))},async(t,e)=>((a,t)=>h(K(l,a),t))(t,e)?j(A(T(await a(I+m(t)),(a=>{return[a[e],E?(t=X(a,e),n=E,j(Y(t,((a,t)=>[t,n(a,t)])))):X(a,e)];var t,n})),(([a,t])=>!i(a)&&!W(t)))):{},async(t,n,s,E,y,u=!1)=>{const g=ta();Y(s??{},(a=>T(G(a??{}),(a=>ea(g,a)))));const p=b(g);if(!u&&y&&R(p)&&h(l,t))return await a("DROP "+v+m(t)),void Q(l,t);const C=K(l,t),O=ta(b(C));if(R(p)||(h(l,t)?await w(T([n,...p],(async(e,s)=>{P(O,e)||(await a($+m(t)+"ADD"+m(e)+r),0==s&&await a("CREATE UNIQUE INDEX pk ON "+m(t)+`(${m(n)})`),ea(C,e))}))):(await a("CREATE "+v+m(t)+`(${m(n)}${r} PRIMARY KEY${d(T(p,(a=>e+m(a)+r)))});`),Q(l,t,ta([n,...p])))),await w([...!u&&E?T(b(O),(async e=>{e!=n&&(await a($+m(t)+"DROP"+m(e)),P(C,e))})):[]]),u)i(s)?await a(S+m(t)+L+" true"):await w(Y(s,(async(e,s)=>{i(e)?await a(S+m(t)+L+m(n)+"=$1",[s]):R(p)||await o(a,t,n,G(e),{[s]:c?T(q(e),c):q(e)},C)})));else if(R(p))h(l,t)&&await a(S+m(t)+L+" true");else{const e=A(b(K(l,t)),(a=>a!=n)),i={},r=[];Y(s??{},((a,t)=>{i[t]=T(e,(t=>c?c(a?.[t]):a?.[t])),N(r,t)})),await o(a,t,n,e,i),await a(S+m(t)+L+m(n)+`NOT IN(${_(r)})`,r)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){s?.(a)}return await a("END"),e}]},ca=async(a,t,n,s,i)=>{const r=[1];await a("INSERT INTO"+m(t)+"("+((...a)=>d(T(a,m),e))(n,...s)+")VALUES"+d(Y(i,(a=>"($"+r[0]+++","+_(a,r)+")")),e)+"ON CONFLICT("+m(n)+")DO UPDATE SET"+d(T(s,(a=>m(a)+"=excluded."+m(a))),e),Y(i,((a,t)=>[t,...T(a,(a=>a??null))])).flat())},Ea=(a,t,e,n,s,i,r,[o,c,E],l,w,y,u,d,T)=>{const[R,A,N,g]=oa(t,l,w,s,d,T),C=ra(a,(async()=>await g((async()=>{return await R(),a=(await A(o,c))[p]?.[E]??"null",z(a,((a,t)=>"￼"===t?void 0:t));var a}))),(async a=>await g((async()=>{var t;await R(),await N(o,c,{[p]:{[E]:(t=a()??null,k(t,((a,t)=>void 0===t?"￼":t)))}},!0,!0)}))),e,n,s,r,{[u]:()=>y,destroy:()=>(C.stopAutoLoad().stopAutoSave(),i(),C)},0,y);return C},la=(a,t,e,n,s,r,o,[c,E,[l,y,u]],d,T,R,N,g,O,L,v)=>{const[$,S,I,m]=oa(t,d,T,s,g,O,L,v),_=async(a,t)=>await w(V(E,(async([e,n,s,i],r)=>{t&&!(r in a)||await I(e,n,a[r],s,i,t)}))),h=async(a,t)=>y?await I(u,C,{[p]:a},!0,!0,t):null,f=ra(a,(async()=>await m((async()=>{await $();const a=await(async()=>j(A(await w(V(c,(async([a,t],e)=>[a,await S(e,t)]))),(a=>!W(a[1])))))(),t=await(async()=>l?(await S(u,C))[p]:{})();return W(a)&&i(t)?void 0:[a,t]}))),(async(a,t)=>await m((async()=>{if(await $(),i(t)){const[t,e]=a();await _(t),await h(e)}else await _(t[0],!0),await h(t[1],!0)}))),e,n,s,o,{[N]:()=>R,destroy:()=>(f.stopAutoLoad().stopAutoSave(),r(),f)},0,R);return f},wa="ColumnName",ya="store",ua="json",da=ya+"TableName",Ta=ya+"Id"+wa,Ra=ya+wa,Aa="autoLoadIntervalSeconds",Na="rowId"+wa,ga="tableId",pa="tableName",Ca="deleteEmptyColumns",Oa="deleteEmptyTable",La={mode:ua,[Aa]:1},va={load:0,save:0,[pa]:t+"_values"},$a=(a,t,e,n,s)=>{const r=J();return Y(a,((a,c)=>{const l=E(q(x(t,o(a)?{[e]:a}:a)),0,H(t));i(l[0])||n(c,l[0])||(s(c,l[0]),Q(r,c,l))})),r},Sa=t,Ia=/^([cd]:)(.+)/,ma=t+"_data",_a=t+"_table",ha=async(a,e,n,s,i)=>{const c=await(e.reserve?.());return((a,e,n,s,i,c,l,y,u,d,R="getDb")=>{const A=((a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a)(n,c),[N,,g,p]=(a=>{const e=(a=>x(La,o(a)?{[da]:a}:a??{}))(a),n=e[Aa];if(e.mode==ua){const a=e[da]??t;return[1,n,[a,e[Ta]??C,e[Ra]??ya],ta(a)]}const{tables:{load:s={},save:i={}}={},values:r={}}=e,c=E(q(x(va,r)),0,H(va)),l=c[2],w=ta(l),y=ta(l);return[0,n,[$a(s,{[ga]:null,[Na]:C},ga,(a=>h(y,a)),(a=>ea(w,a))),$a(i,{[pa]:null,[Na]:C,[Ca]:0,[Oa]:0},pa,((a,t)=>h(y,t)),((a,t)=>ea(w,t))),c],w]})(e),v=async a=>{await A(`CREATE OR REPLACE TRIGGER ${m(ma+"_"+a)} AFTER INSERT OR UPDATE OR DELETE ON ${m(a)} EXECUTE FUNCTION ${ma}()`)};return(N?Ea:la)(a,A,(async a=>{await A(`CREATE OR REPLACE FUNCTION ${_a}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${Sa}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await A(`CREATE EVENT TRIGGER ${_a} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${_a}();`)}catch{}return await A(`CREATE OR REPLACE FUNCTION ${ma}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${Sa}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await w(T(b(p),(async a=>{await A(`CREATE TABLE IF NOT EXISTS ${m(a)}("_id"text PRIMARY KEY)`),await v(a)}))),await s(Sa,(async t=>{return await r((e=t,n=Ia,e?.match(n)),(async([,t,e])=>{h(p,e)&&("c:"==t&&await v(e),a())}));var e,n}))}),i,l,y,u,g,b(p),(async(a,t)=>await a(`${O} table_name tn,column_name cn FROM information_schema.columns ${L} table_schema='public'AND table_name IN(${_(t)})`,t)),d,R,"text",void 0,(a=>k(a)),(a=>z(a)))})(a,n,c?.unsafe,(async(a,t)=>e.listen(a,t)),(async a=>{try{await a.unlisten()}catch(a){i?.(a)}}),s,i,(()=>c?.release?.()),3,e,"getSql")};export{ha as createPostgresPersister};
