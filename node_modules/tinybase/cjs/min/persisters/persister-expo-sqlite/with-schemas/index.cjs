"use strict";var a=require("expo-sqlite");const t=a=>typeof a,e="tinybase",n="",s=",",r=t(n),i=Promise,o=clearInterval,c=a=>null==a,l=(a,t,e)=>c(a)?e?.():t(a),u=a=>t(a)==r,y=a=>Array.isArray(a),w=(a,t,e)=>a.slice(t,e),d=a=>a.length,v=async a=>i.all(a),p=a=>{throw Error(a)},E=(a,t)=>a.forEach(t),g=(a,t="")=>a.join(t),A=(a,t)=>a.map(t),m=a=>0==d(a),h=(a,t)=>a.filter(t),N=(a,...t)=>a.push(...t),$=a=>a.shift(),S="_",f="_id",C="SELECT",O="WHERE",T="TABLE",b="ALTER "+T,L="DELETE FROM",I=C+"*FROM",D="pragma_",R="data_version",M="schema_version",_="pragma_table_",P=a=>`"${a.replace(/"/g,'""')}"`,F=(a,t=[1])=>g(A(a,(()=>"$"+t[0]++)),s),x=(a,t)=>a?.has(t)??!1,U=a=>c(a)||0==(a=>a?.size??0)(a),j=a=>[...a?.values()??[]],q=(a,t)=>a?.forEach(t),B=(a,t)=>a?.delete(t),J=Object,Y=a=>J.getPrototypeOf(a),k=J.entries,z=J.keys,G=J.freeze,H=(a=[])=>J.fromEntries(a),K=(...a)=>J.assign({},...a),Q=(a,t)=>(delete a[t],a),V=(a,t)=>A(k(a),(([a,e])=>t(e,a))),W=a=>J.values(a),X=a=>d(z(a)),Z=a=>(a=>!c(a)&&l(Y(a),(a=>a==J.prototype||c(Y(a))),(()=>!0)))(a)&&0==X(a),aa=JSON.stringify,ta=JSON.parse,ea=a=>new Map(a),na=(a,t)=>a?.get(t),sa=(a,t)=>A([...a?.entries()??[]],(([a,e])=>t(e,a))),ra=(a,t,e)=>c(e)?(B(a,t),a):a?.set(t,e),ia=(a,t,e,n)=>(x(a,t)?n?.(na(a,t)):ra(a,t,e()),na(a,t)),oa=(a,t,e,n,s=0)=>l((e?ia:na)(a,t[s],s>d(t)-2?e:ea),(r=>{if(s>d(t)-2)return n?.(r)&&ra(a,t[s]),r;const i=oa(r,t,e,n,s+1);return U(r)&&ra(a,t[s]),i})),ca=a=>new Set(y(a)||c(a)?a:[a]),la=(a,t)=>a?.add(t),ua=/^\d+$/,ya=ea(),wa=ea(),da=(a,t,e,s,r,i,o,u={},w=0,v=[])=>{let g,A,m,h=0,S=0,f=0;ia(ya,v,(()=>0)),ia(wa,v,(()=>[]));const C=ea(),[O,T,b,L,I]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!Z(a)||!Z(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!Z(a)||!Z(t),t.setContent]:p("Store type not supported by this Persister"))(o,a,w),[D,R,M]=(()=>{let a;const[t,e]=(()=>{const a=[];let t=0;return[e=>(e?$(a):null)??n+t++,t=>{ua.test(t)&&d(a)<1e3&&N(a,t)}]})(),s=ea();return[(e,r,i,o=[],c=()=>[])=>{a??=k;const l=t(1);return ra(s,l,[e,r,i,o,c]),la(oa(r,i??[n],ca),l),l},(t,e,...r)=>E(((a,t=[n])=>{const e=[],s=(a,n)=>n==d(t)?N(e,a):null===t[n]?q(a,(a=>s(a,n+1))):E([t[n],null],(t=>s(na(a,t),n+1)));return s(a,0),e})(t,e),(t=>q(t,(t=>na(s,t)[0](a,...e??[],...r))))),a=>l(na(s,a),(([,t,r])=>(oa(t,r??[n],void 0,(t=>(B(t,a),U(t)?1:0))),ra(s,a),e(a),r))),t=>l(na(s,t),(([t,,e=[],n,s])=>{const r=(...i)=>{const o=d(i);o==d(e)?t(a,...i,...s(i)):c(e[o])?E(n[o]?.(...i)??[],(a=>r(...i,a))):r(...i,e[o])};r()}))]})(),_=a=>{a!=h&&(h=a,R(C,void 0,h))},P=t=>{(O&&y(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},F=async a=>(2!=h&&(_(1),S++,await Y((async()=>{try{const e=await t();y(e)?P(e):a?I(a):p("Content is not an array: "+e)}catch(t){i?.(t),a&&I(a)}_(0)}))),k),x=()=>(A&&(r(A),A=void 0),k),j=async a=>(1!=h&&(_(2),f++,await Y((async()=>{try{await e(T,a)}catch(a){i?.(a)}_(0)}))),k),J=()=>(m&&(a.delListener(m),m=void 0),k),Y=async(...a)=>(N(na(wa,v),...a),await(async()=>{if(!na(ya,v)){for(ra(ya,v,1);!c(g=$(na(wa,v)));)try{await g()}catch(a){i?.(a)}ra(ya,v,0)}})(),k),k={load:F,startAutoLoad:async a=>{x(),await F(a);try{A=await s((async(a,t)=>{t||a?2!=h&&(_(1),S++,P(t??a),_(0)):await F()}))}catch(a){i?.(a)}return k},stopAutoLoad:x,isAutoLoading:()=>!c(A),save:j,startAutoSave:async()=>(J(),await j(),m=a.addDidFinishTransactionListener((()=>{const a=b();L(a)&&j(a)})),k),stopAutoSave:J,isAutoSaving:()=>!c(m),getStatus:()=>h,addStatusListener:a=>D(a,C),delListener:t=>(M(t),a),schedule:Y,getStore:()=>a,destroy:()=>(na(wa,v).splice(0,void 0),x().stopAutoSave()),getStats:()=>({loads:S,saves:f}),...u};return G(k)},va=(a,t,e,n,r,i=pa,o,l)=>{const u=ea();return[async()=>{u.clear(),A(await e(a,t),(({tn:a,cn:t})=>la(ia(u,a,ca),t)))},async(t,e)=>((a,t)=>x(na(u,a),t))(t,e)?H(h(A(await a(I+P(t)),(a=>{return[a[e],l?(t=Q(a,e),n=l,H(V(t,((a,t)=>[t,n(a,t)])))):Q(a,e)];var t,n})),(([a,t])=>!c(a)&&!Z(t)))):{},async(t,e,n,l,y,w=!1)=>{const d=ca();V(n??{},(a=>A(z(a??{}),(a=>la(d,a)))));const p=j(d);if(!w&&y&&m(p)&&x(u,t))return await a("DROP "+T+P(t)),void ra(u,t);const E=na(u,t),$=ca(j(E));if(m(p)||(x(u,t)?await v(A([e,...p],(async(n,s)=>{B($,n)||(await a(b+P(t)+"ADD"+P(n)+r),0==s&&await a("CREATE UNIQUE INDEX pk ON "+P(t)+`(${P(e)})`),la(E,n))}))):(await a("CREATE "+T+P(t)+`(${P(e)}${r} PRIMARY KEY${g(A(p,(a=>s+P(a)+r)))});`),ra(u,t,ca([e,...p])))),await v([...!w&&l?A(j($),(async n=>{n!=e&&(await a(b+P(t)+"DROP"+P(n)),B(E,n))})):[]]),w)c(n)?await a(L+P(t)+O+" true"):await v(V(n,(async(n,s)=>{c(n)?await a(L+P(t)+O+P(e)+"=$1",[s]):m(p)||await i(a,t,e,z(n),{[s]:o?A(W(n),o):W(n)},E)})));else if(m(p))x(u,t)&&await a(L+P(t)+O+" true");else{const s=h(j(na(u,t)),(a=>a!=e)),r={},c=[];V(n??{},((a,t)=>{r[t]=A(s,(t=>o?o(a?.[t]):a?.[t])),N(c,t)})),await i(a,t,e,s,r),await a(L+P(t)+O+P(e)+`NOT IN(${F(c)})`,c)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){n?.(a)}return await a("END"),e}]},pa=async(a,t,e,n,r)=>{const i=[1];await a("INSERT INTO"+P(t)+"("+((...a)=>g(A(a,P),s))(e,...n)+")VALUES"+g(V(r,(a=>"($"+i[0]+++","+F(a,i)+")")),s)+"ON CONFLICT("+P(e)+")DO UPDATE SET"+g(A(n,(a=>P(a)+"=excluded."+P(a))),s),V(r,((a,t)=>[t,...A(a,(a=>a??null))])).flat())},Ea=(a,t,e,n,s,r,i,[o,c,l],u,y,w,d,v,p)=>{const[E,g,A,m]=va(t,u,y,s,v,p),h=da(a,(async()=>await m((async()=>{return await E(),a=(await g(o,c))[S]?.[l]??"null",ta(a,((a,t)=>"ï¿¼"===t?void 0:t));var a}))),(async a=>await m((async()=>{var t;await E(),await A(o,c,{[S]:{[l]:(t=a()??null,aa(t,((a,t)=>void 0===t?"ï¿¼":t)))}},!0,!0)}))),e,n,s,i,{[d]:()=>w,destroy:()=>(h.stopAutoLoad().stopAutoSave(),r(),h)},0,w);return h},ga=(a,t,e,n,s,r,i,[o,l,[u,y,w]],d,p,E,g,A,m,N,$)=>{const[C,O,T,b]=va(t,d,p,s,A,m,N,$),L=async(a,t)=>await v(sa(l,(async([e,n,s,r],i)=>{t&&!(i in a)||await T(e,n,a[i],s,r,t)}))),I=async(a,t)=>y?await T(w,f,{[S]:a},!0,!0,t):null,D=da(a,(async()=>await b((async()=>{await C();const a=await(async()=>H(h(await v(sa(o,(async([a,t],e)=>[a,await O(e,t)]))),(a=>!Z(a[1])))))(),t=await(async()=>u?(await O(w,f))[S]:{})();return Z(a)&&c(t)?void 0:[a,t]}))),(async(a,t)=>await b((async()=>{if(await C(),c(t)){const[t,e]=a();await L(t),await I(e)}else await L(t[0],!0),await I(t[1],!0)}))),e,n,s,i,{[g]:()=>E,destroy:()=>(D.stopAutoLoad().stopAutoSave(),r(),D)},0,E);return D},Aa="ColumnName",ma="store",ha="json",Na=ma+"TableName",$a=ma+"Id"+Aa,Sa=ma+Aa,fa="autoLoadIntervalSeconds",Ca="rowId"+Aa,Oa="tableId",Ta="tableName",ba="deleteEmptyColumns",La="deleteEmptyTable",Ia={mode:ha,[fa]:1},Da={load:0,save:0,[Ta]:e+"_values"},Ra=(a,t,e,n,s)=>{const r=ea();return V(a,((a,i)=>{const o=w(W(K(t,u(a)?{[e]:a}:a)),0,X(t));c(o[0])||n(i,o[0])||(s(i,o[0]),ra(r,i,o))})),r},Ma=(a,t,s,r,i,c,l,y,d,v,p="getDb",E)=>{let g,A,m;const h=((a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a)(s,c),[N,$,S,T]=(a=>{const t=(a=>K(Ia,u(a)?{[Na]:a}:a??{}))(a),n=t[fa];if(t.mode==ha){const a=t[Na]??e;return[1,n,[a,t[$a]??f,t[Sa]??ma],ca(a)]}const{tables:{load:s={},save:r={}}={},values:i={}}=t,o=w(W(K(Da,i)),0,X(Da)),c=o[2],l=ca(c),y=ca(c);return[0,n,[Ra(s,{[Oa]:null,[Ca]:f},Oa,(a=>x(y,a)),(a=>la(l,a))),Ra(r,{[Ta]:null,[Ca]:f,[ba]:0,[La]:0},Ta,((a,t)=>x(y,t)),((a,t)=>la(l,t))),o],l]})(t);return(N?Ea:ga)(a,h,(a=>{let t;const e=()=>t=setInterval((async()=>{try{const[{d:t,s:e,c:n}]=await h(`${C} ${R} d,${M} s,TOTAL_CHANGES() c FROM ${D}${R} JOIN ${D}${M}`);t==g&&e==A&&n==m||(null!=g&&a(),g=t,A=e,m=n)}catch{}}),1e3*$),n=()=>{g=A=m=null,o(t)},s=r((t=>{T.has(t)&&(n(),a(),e())}));return e(),()=>{n(),i(s)}}),(a=>a()),l,y,d,S,j(T),(async(a,t)=>await a(`${C} t.name tn,c.name cn FROM ${_}list()t,${_}info(t.name)c ${O} t.schema='main'AND t.type IN('table','view')AND t.name IN(${F(t)})ORDER BY t.name,c.name`,t)),v,p,n,E,(a=>!0===a?1:!1===a?0:a),void 0)};exports.createExpoSqlitePersister=(t,e,n,s,r)=>Ma(t,n,(async(a,t=[])=>await e.getAllAsync(a,t)),(t=>a.addDatabaseChangeListener((({tableName:a})=>t(a)))),(a=>a.remove()),s,r,(()=>0),3,e);
