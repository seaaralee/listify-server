"use strict";const t=t=>typeof t,a="tinybase",e="",n=",",s=t(e),r=Promise,i=clearInterval,o=t=>null==t,c=(t,a,e)=>o(t)?e?.():a(t),l=a=>t(a)==s,E=t=>Array.isArray(t),w=(t,a,e)=>t.slice(a,e),y=t=>t.length,u=async t=>r.all(t),d=t=>{throw Error(t)},R=(t,a)=>t.forEach(a),A=(t,a="")=>t.join(a),T=(t,a)=>t.map(a),N=t=>0==y(t),g=(t,a)=>t.filter(a),p=(t,...a)=>t.push(...a),O=t=>t.shift(),$=Object,m=t=>$.getPrototypeOf(t),C=$.entries,v=$.keys,S=$.freeze,L=(t=[])=>$.fromEntries(t),I=(...t)=>$.assign({},...t),_=(t,a)=>(delete t[a],t),h=(t,a)=>T(C(t),(([t,e])=>a(e,t))),b=t=>$.values(t),f=t=>y(v(t)),D=t=>(t=>!o(t)&&c(m(t),(t=>t==$.prototype||o(m(t))),(()=>!0)))(t)&&0==f(t),P=(t,a)=>t?.has(a)??!1,M=t=>o(t)||0==(t=>t?.size??0)(t),F=t=>[...t?.values()??[]],U=(t,a)=>t?.forEach(a),G=(t,a)=>t?.delete(a),B=t=>new Map(t),x=(t,a)=>t?.get(a),j=(t,a)=>T([...t?.entries()??[]],(([t,e])=>a(e,t))),Y=(t,a,e)=>o(e)?(G(t,a),t):t?.set(a,e),q=(t,a,e,n)=>(P(t,a)?n?.(x(t,a)):Y(t,a,e()),x(t,a)),H=(t,a,e,n,s=0)=>c((e?q:x)(t,a[s],s>y(a)-2?e:B),(r=>{if(s>y(a)-2)return n?.(r)&&Y(t,a[s]),r;const i=H(r,a,e,n,s+1);return M(r)&&Y(t,a[s]),i})),X=t=>new Set(E(t)||o(t)?t:[t]),J=(t,a)=>t?.add(a),W=/^\d+$/,k=B(),z=B(),K=(t,a,n,s,r,i,l,w={},u=0,A=[])=>{let T,N,g,$=0,m=0,C=0;q(k,A,(()=>0)),q(z,A,(()=>[]));const v=B(),[L,I,_,h,b]=((t=1,a,e)=>1!=t&&a.isMergeable()?[1,a.getMergeableContent,()=>a.getTransactionMergeableChanges(!e),([[t],[a]])=>!D(t)||!D(a),a.setDefaultContent]:2!=t?[0,a.getContent,a.getTransactionChanges,([t,a])=>!D(t)||!D(a),a.setContent]:d("Store type not supported by this Persister"))(l,t,u),[f,P,F]=(()=>{let t;const[a,n]=(()=>{const t=[];let a=0;return[n=>(n?O(t):null)??e+a++,a=>{W.test(a)&&y(t)<1e3&&p(t,a)}]})(),s=B();return[(n,r,i,o=[],c=()=>[])=>{t??=et;const l=a(1);return Y(s,l,[n,r,i,o,c]),J(H(r,i??[e],X),l),l},(a,n,...r)=>R(((t,a=[e])=>{const n=[],s=(t,e)=>e==y(a)?p(n,t):null===a[e]?U(t,(t=>s(t,e+1))):R([a[e],null],(a=>s(x(t,a),e+1)));return s(t,0),n})(a,n),(a=>U(a,(a=>x(s,a)[0](t,...n??[],...r))))),t=>c(x(s,t),(([,a,r])=>(H(a,r??[e],void 0,(a=>(G(a,t),M(a)?1:0))),Y(s,t),n(t),r))),a=>c(x(s,a),(([a,,e=[],n,s])=>{const r=(...i)=>{const c=y(i);c==y(e)?a(t,...i,...s(i)):o(e[c])?R(n[c]?.(...i)??[],(t=>r(...i,t))):r(...i,e[c])};r()}))]})(),j=t=>{t!=$&&($=t,P(v,void 0,$))},K=a=>{(L&&E(a?.[0])?1===a?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===a?.[2]?t.applyChanges:t.setContent)(a)},V=async t=>(2!=$&&(j(1),m++,await at((async()=>{try{const e=await a();E(e)?K(e):t?b(t):d("Content is not an array: "+e)}catch(a){i?.(a),t&&b(t)}j(0)}))),et),Q=()=>(N&&(r(N),N=void 0),et),Z=async t=>(1!=$&&(j(2),C++,await at((async()=>{try{await n(I,t)}catch(t){i?.(t)}j(0)}))),et),tt=()=>(g&&(t.delListener(g),g=void 0),et),at=async(...t)=>(p(x(z,A),...t),await(async()=>{if(!x(k,A)){for(Y(k,A,1);!o(T=O(x(z,A)));)try{await T()}catch(t){i?.(t)}Y(k,A,0)}})(),et),et={load:V,startAutoLoad:async t=>{Q(),await V(t);try{N=await s((async(t,a)=>{a||t?2!=$&&(j(1),m++,K(a??t),j(0)):await V()}))}catch(t){i?.(t)}return et},stopAutoLoad:Q,isAutoLoading:()=>!o(N),save:Z,startAutoSave:async()=>(tt(),await Z(),g=t.addDidFinishTransactionListener((()=>{const t=_();h(t)&&Z(t)})),et),stopAutoSave:tt,isAutoSaving:()=>!o(g),getStatus:()=>$,addStatusListener:t=>f(t,v),delListener:a=>(F(a),t),schedule:at,getStore:()=>t,destroy:()=>(x(z,A).splice(0,void 0),Q().stopAutoSave()),getStats:()=>({loads:m,saves:C}),...w};return S(et)},V="_",Q="_id",Z="SELECT",tt="WHERE",at="TABLE",et="ALTER "+at,nt="DELETE FROM",st=Z+"*FROM",rt="pragma_",it="data_version",ot="schema_version",ct="pragma_table_",lt=(t,a)=>a?async(e,n)=>(a(e,n),await t(e,n)):t,Et=t=>`"${t.replace(/"/g,'""')}"`,wt=(t,a=[1])=>A(T(t,(()=>"$"+a[0]++)),n),yt=JSON.stringify,ut=JSON.parse,dt=(t,a,e,s,r,i=Rt,c,l)=>{const E=B();return[async()=>{E.clear(),T(await e(t,a),(({tn:t,cn:a})=>J(q(E,t,X),a)))},async(a,e)=>((t,a)=>P(x(E,t),a))(a,e)?L(g(T(await t(st+Et(a)),(t=>{return[t[e],l?(a=_(t,e),n=l,L(h(a,((t,a)=>[a,n(t,a)])))):_(t,e)];var a,n})),(([t,a])=>!o(t)&&!D(a)))):{},async(a,e,s,l,w,y=!1)=>{const d=X();h(s??{},(t=>T(v(t??{}),(t=>J(d,t)))));const R=F(d);if(!y&&w&&N(R)&&P(E,a))return await t("DROP "+at+Et(a)),void Y(E,a);const O=x(E,a),$=X(F(O));if(N(R)||(P(E,a)?await u(T([e,...R],(async(n,s)=>{G($,n)||(await t(et+Et(a)+"ADD"+Et(n)+r),0==s&&await t("CREATE UNIQUE INDEX pk ON "+Et(a)+`(${Et(e)})`),J(O,n))}))):(await t("CREATE "+at+Et(a)+`(${Et(e)}${r} PRIMARY KEY${A(T(R,(t=>n+Et(t)+r)))});`),Y(E,a,X([e,...R])))),await u([...!y&&l?T(F($),(async n=>{n!=e&&(await t(et+Et(a)+"DROP"+Et(n)),G(O,n))})):[]]),y)o(s)?await t(nt+Et(a)+tt+" true"):await u(h(s,(async(n,s)=>{o(n)?await t(nt+Et(a)+tt+Et(e)+"=$1",[s]):N(R)||await i(t,a,e,v(n),{[s]:c?T(b(n),c):b(n)},O)})));else if(N(R))P(E,a)&&await t(nt+Et(a)+tt+" true");else{const n=g(F(x(E,a)),(t=>t!=e)),r={},o=[];h(s??{},((t,a)=>{r[a]=T(n,(a=>c?c(t?.[a]):t?.[a])),p(o,a)})),await i(t,a,e,n,r),await t(nt+Et(a)+tt+Et(e)+`NOT IN(${wt(o)})`,o)}},async a=>{let e;await t("BEGIN");try{e=await a()}catch(t){s?.(t)}return await t("END"),e}]},Rt=async(t,a,e,s,r)=>{const i=[1];await t("INSERT INTO"+Et(a)+"("+((...t)=>A(T(t,Et),n))(e,...s)+")VALUES"+A(h(r,(t=>"($"+i[0]+++","+wt(t,i)+")")),n)+"ON CONFLICT("+Et(e)+")DO UPDATE SET"+A(T(s,(t=>Et(t)+"=excluded."+Et(t))),n),h(r,((t,a)=>[a,...T(t,(t=>t??null))])).flat())},At=(t,a,e,n,s,r,i,[o,c,l],E,w,y,u,d,R)=>{const[A,T,N,g]=dt(a,E,w,s,d,R),p=K(t,(async()=>await g((async()=>{return await A(),t=(await T(o,c))[V]?.[l]??"null",ut(t,((t,a)=>"￼"===a?void 0:a));var t}))),(async t=>await g((async()=>{var a;await A(),await N(o,c,{[V]:{[l]:(a=t()??null,yt(a,((t,a)=>void 0===a?"￼":a)))}},!0,!0)}))),e,n,s,i,{[u]:()=>y,destroy:()=>(p.stopAutoLoad().stopAutoSave(),r(),p)},0,y);return p},Tt=(t,a,e,n,s,r,i,[c,l,[E,w,y]],d,R,A,T,N,p,O,$)=>{const[m,C,v,S]=dt(a,d,R,s,N,p,O,$),I=async(t,a)=>await u(j(l,(async([e,n,s,r],i)=>{a&&!(i in t)||await v(e,n,t[i],s,r,a)}))),_=async(t,a)=>w?await v(y,Q,{[V]:t},!0,!0,a):null,h=K(t,(async()=>await S((async()=>{await m();const t=await(async()=>L(g(await u(j(c,(async([t,a],e)=>[t,await C(e,a)]))),(t=>!D(t[1])))))(),a=await(async()=>E?(await C(y,Q))[V]:{})();return D(t)&&o(a)?void 0:[t,a]}))),(async(t,a)=>await S((async()=>{if(await m(),o(a)){const[a,e]=t();await I(a),await _(e)}else await I(a[0],!0),await _(a[1],!0)}))),e,n,s,i,{[T]:()=>A,destroy:()=>(h.stopAutoLoad().stopAutoSave(),r(),h)},0,A);return h},Nt="ColumnName",gt="store",pt="json",Ot=gt+"TableName",$t=gt+"Id"+Nt,mt=gt+Nt,Ct="autoLoadIntervalSeconds",vt="rowId"+Nt,St="tableId",Lt="tableName",It="deleteEmptyColumns",_t="deleteEmptyTable",ht={mode:pt,[Ct]:1},bt={load:0,save:0,[Lt]:a+"_values"},ft=(t,a,e,n,s)=>{const r=B();return h(t,((t,i)=>{const c=w(b(I(a,l(t)?{[e]:t}:t)),0,f(a));o(c[0])||n(i,c[0])||(s(i,c[0]),Y(r,i,c))})),r},Dt=t=>{const e=(t=>I(ht,l(t)?{[Ot]:t}:t??{}))(t),n=e[Ct];if(e.mode==pt){const t=e[Ot]??a;return[1,n,[t,e[$t]??Q,e[mt]??gt],X(t)]}const{tables:{load:s={},save:r={}}={},values:i={}}=e,o=w(b(I(bt,i)),0,f(bt)),c=o[2],E=X(c),y=X(c);return[0,n,[ft(s,{[St]:null,[vt]:Q},St,(t=>P(y,t)),(t=>J(E,t))),ft(r,{[Lt]:null,[vt]:Q,[It]:0,[_t]:0},Lt,((t,a)=>P(y,a)),((t,a)=>J(E,a))),o],E]},Pt=a,Mt=/^([cd]:)(.+)/,Ft=a+"_data",Ut=a+"_table";exports.Persists={StoreOnly:1,MergeableStoreOnly:2,StoreOrMergeableStore:3},exports.Status={Idle:0,Loading:1,Saving:2},exports.createCustomPersister=K,exports.createCustomPostgreSqlPersister=(t,a,e,n,s,r,i,o,l,E,w="getDb")=>{const y=lt(e,r),[d,,R,A]=Dt(a),N=async t=>{await y(`CREATE OR REPLACE TRIGGER ${Et(Ft+"_"+t)} AFTER INSERT OR UPDATE OR DELETE ON ${Et(t)} EXECUTE FUNCTION ${Ft}()`)};return(d?At:Tt)(t,y,(async t=>{await y(`CREATE OR REPLACE FUNCTION ${Ut}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${Pt}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await y(`CREATE EVENT TRIGGER ${Ut} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${Ut}();`)}catch{}return await y(`CREATE OR REPLACE FUNCTION ${Ft}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${Pt}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await u(T(F(A),(async t=>{await y(`CREATE TABLE IF NOT EXISTS ${Et(t)}("_id"text PRIMARY KEY)`),await N(t)}))),await n(Pt,(async a=>{return await c((e=a,n=Mt,e?.match(n)),(async([,a,e])=>{P(A,e)&&("c:"==a&&await N(e),t())}));var e,n}))}),s,i,o,l,R,F(A),(async(t,a)=>await t(`${Z} table_name tn,column_name cn FROM information_schema.columns ${tt} table_schema='public'AND table_name IN(${wt(a)})`,a)),E,w,"text",void 0,(t=>yt(t)),(t=>ut(t)))},exports.createCustomSqlitePersister=(t,a,n,s,r,o,c,l,E,w,y="getDb",u)=>{let d,R,A;const T=lt(n,o),[N,g,p,O]=Dt(a);return(N?At:Tt)(t,T,(t=>{let a;const e=()=>a=setInterval((async()=>{try{const[{d:a,s:e,c:n}]=await T(`${Z} ${it} d,${ot} s,TOTAL_CHANGES() c FROM ${rt}${it} JOIN ${rt}${ot}`);a==d&&e==R&&n==A||(null!=d&&t(),d=a,R=e,A=n)}catch{}}),1e3*g),n=()=>{d=R=A=null,i(a)},o=s((a=>{O.has(a)&&(n(),t(),e())}));return e(),()=>{n(),r(o)}}),(t=>t()),c,l,E,p,F(O),(async(t,a)=>await t(`${Z} t.name tn,c.name cn FROM ${ct}list()t,${ct}info(t.name)c ${tt} t.schema='main'AND t.type IN('table','view')AND t.name IN(${wt(a)})ORDER BY t.name,c.name`,a)),w,y,e,u,(t=>!0===t?1:!1===t?0:t),void 0)};
