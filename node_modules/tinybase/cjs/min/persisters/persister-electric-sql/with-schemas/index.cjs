"use strict";const a=a=>typeof a,t="tinybase",e="",n=",",s=a(e),i=Promise,r=clearInterval,o=a=>null==a,c=(a,t,e)=>o(a)?e?.():t(a),l=t=>a(t)==s,u=a=>Array.isArray(a),w=(a,t,e)=>a.slice(t,e),y=a=>a.length,d=async a=>i.all(a),v=a=>{throw Error(a)},E=(a,t)=>a.forEach(t),p=(a,t="")=>a.join(t),g=(a,t)=>a.map(t),A=a=>0==y(a),h=(a,t)=>a.filter(t),m=(a,...t)=>a.push(...t),f=a=>a.shift(),N="_",$="_id",C="SELECT",S="WHERE",b="TABLE",T="ALTER "+b,O="DELETE FROM",I=C+"*FROM",L="pragma_",D="data_version",R="schema_version",M="pragma_table_",_=a=>`"${a.replace(/"/g,'""')}"`,P=(a,t=[1])=>p(g(a,(()=>"$"+t[0]++)),n),F=(a,t)=>a?.has(t)??!1,U=a=>o(a)||0==(a=>a?.size??0)(a),j=a=>[...a?.values()??[]],B=(a,t)=>a?.forEach(t),J=(a,t)=>a?.delete(t),Y=Object,k=a=>Y.getPrototypeOf(a),q=Y.entries,x=Y.keys,z=Y.freeze,G=(a=[])=>Y.fromEntries(a),H=(...a)=>Y.assign({},...a),K=(a,t)=>(delete a[t],a),Q=(a,t)=>g(q(a),(([a,e])=>t(e,a))),V=a=>Y.values(a),W=a=>y(x(a)),X=a=>(a=>!o(a)&&c(k(a),(a=>a==Y.prototype||o(k(a))),(()=>!0)))(a)&&0==W(a),Z=JSON.stringify,aa=JSON.parse,ta=a=>new Map(a),ea=(a,t)=>a?.get(t),na=(a,t)=>g([...a?.entries()??[]],(([a,e])=>t(e,a))),sa=(a,t,e)=>o(e)?(J(a,t),a):a?.set(t,e),ia=(a,t,e,n)=>(F(a,t)?n?.(ea(a,t)):sa(a,t,e()),ea(a,t)),ra=(a,t,e,n,s=0)=>c((e?ia:ea)(a,t[s],s>y(t)-2?e:ta),(i=>{if(s>y(t)-2)return n?.(i)&&sa(a,t[s]),i;const r=ra(i,t,e,n,s+1);return U(i)&&sa(a,t[s]),r})),oa=a=>new Set(u(a)||o(a)?a:[a]),ca=(a,t)=>a?.add(t),la=/^\d+$/,ua=ta(),wa=ta(),ya=(a,t,n,s,i,r,l,w={},d=0,p=[])=>{let g,A,h,N=0,$=0,C=0;ia(ua,p,(()=>0)),ia(wa,p,(()=>[]));const S=ta(),[b,T,O,I,L]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!X(a)||!X(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!X(a)||!X(t),t.setContent]:v("Store type not supported by this Persister"))(l,a,d),[D,R,M]=(()=>{let a;const[t,n]=(()=>{const a=[];let t=0;return[n=>(n?f(a):null)??e+t++,t=>{la.test(t)&&y(a)<1e3&&m(a,t)}]})(),s=ta();return[(n,i,r,o=[],c=()=>[])=>{a??=x;const l=t(1);return sa(s,l,[n,i,r,o,c]),ca(ra(i,r??[e],oa),l),l},(t,n,...i)=>E(((a,t=[e])=>{const n=[],s=(a,e)=>e==y(t)?m(n,a):null===t[e]?B(a,(a=>s(a,e+1))):E([t[e],null],(t=>s(ea(a,t),e+1)));return s(a,0),n})(t,n),(t=>B(t,(t=>ea(s,t)[0](a,...n??[],...i))))),a=>c(ea(s,a),(([,t,i])=>(ra(t,i??[e],void 0,(t=>(J(t,a),U(t)?1:0))),sa(s,a),n(a),i))),t=>c(ea(s,t),(([t,,e=[],n,s])=>{const i=(...r)=>{const c=y(r);c==y(e)?t(a,...r,...s(r)):o(e[c])?E(n[c]?.(...r)??[],(a=>i(...r,a))):i(...r,e[c])};i()}))]})(),_=a=>{a!=N&&(N=a,R(S,void 0,N))},P=t=>{(b&&u(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},F=async a=>(2!=N&&(_(1),$++,await q((async()=>{try{const e=await t();u(e)?P(e):a?L(a):v("Content is not an array: "+e)}catch(t){r?.(t),a&&L(a)}_(0)}))),x),j=()=>(A&&(i(A),A=void 0),x),Y=async a=>(1!=N&&(_(2),C++,await q((async()=>{try{await n(T,a)}catch(a){r?.(a)}_(0)}))),x),k=()=>(h&&(a.delListener(h),h=void 0),x),q=async(...a)=>(m(ea(wa,p),...a),await(async()=>{if(!ea(ua,p)){for(sa(ua,p,1);!o(g=f(ea(wa,p)));)try{await g()}catch(a){r?.(a)}sa(ua,p,0)}})(),x),x={load:F,startAutoLoad:async a=>{j(),await F(a);try{A=await s((async(a,t)=>{t||a?2!=N&&(_(1),$++,P(t??a),_(0)):await F()}))}catch(a){r?.(a)}return x},stopAutoLoad:j,isAutoLoading:()=>!o(A),save:Y,startAutoSave:async()=>(k(),await Y(),h=a.addDidFinishTransactionListener((()=>{const a=O();I(a)&&Y(a)})),x),stopAutoSave:k,isAutoSaving:()=>!o(h),getStatus:()=>N,addStatusListener:a=>D(a,S),delListener:t=>(M(t),a),schedule:q,getStore:()=>a,destroy:()=>(ea(wa,p).splice(0,void 0),j().stopAutoSave()),getStats:()=>({loads:$,saves:C}),...w};return z(x)},da=(a,t,e,s,i,r=va,c,l)=>{const u=ta();return[async()=>{u.clear(),g(await e(a,t),(({tn:a,cn:t})=>ca(ia(u,a,oa),t)))},async(t,e)=>((a,t)=>F(ea(u,a),t))(t,e)?G(h(g(await a(I+_(t)),(a=>{return[a[e],l?(t=K(a,e),n=l,G(Q(t,((a,t)=>[t,n(a,t)])))):K(a,e)];var t,n})),(([a,t])=>!o(a)&&!X(t)))):{},async(t,e,s,l,w,y=!1)=>{const v=oa();Q(s??{},(a=>g(x(a??{}),(a=>ca(v,a)))));const E=j(v);if(!y&&w&&A(E)&&F(u,t))return await a("DROP "+b+_(t)),void sa(u,t);const f=ea(u,t),N=oa(j(f));if(A(E)||(F(u,t)?await d(g([e,...E],(async(n,s)=>{J(N,n)||(await a(T+_(t)+"ADD"+_(n)+i),0==s&&await a("CREATE UNIQUE INDEX pk ON "+_(t)+`(${_(e)})`),ca(f,n))}))):(await a("CREATE "+b+_(t)+`(${_(e)}${i} PRIMARY KEY${p(g(E,(a=>n+_(a)+i)))});`),sa(u,t,oa([e,...E])))),await d([...!y&&l?g(j(N),(async n=>{n!=e&&(await a(T+_(t)+"DROP"+_(n)),J(f,n))})):[]]),y)o(s)?await a(O+_(t)+S+" true"):await d(Q(s,(async(n,s)=>{o(n)?await a(O+_(t)+S+_(e)+"=$1",[s]):A(E)||await r(a,t,e,x(n),{[s]:c?g(V(n),c):V(n)},f)})));else if(A(E))F(u,t)&&await a(O+_(t)+S+" true");else{const n=h(j(ea(u,t)),(a=>a!=e)),i={},o=[];Q(s??{},((a,t)=>{i[t]=g(n,(t=>c?c(a?.[t]):a?.[t])),m(o,t)})),await r(a,t,e,n,i),await a(O+_(t)+S+_(e)+`NOT IN(${P(o)})`,o)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){s?.(a)}return await a("END"),e}]},va=async(a,t,e,s,i)=>{const r=[1];await a("INSERT INTO"+_(t)+"("+((...a)=>p(g(a,_),n))(e,...s)+")VALUES"+p(Q(i,(a=>"($"+r[0]+++","+P(a,r)+")")),n)+"ON CONFLICT("+_(e)+")DO UPDATE SET"+p(g(s,(a=>_(a)+"=excluded."+_(a))),n),Q(i,((a,t)=>[t,...g(a,(a=>a??null))])).flat())},Ea=(a,t,e,n,s,i,r,[o,c,l],u,w,y,d,v,E)=>{const[p,g,A,h]=da(t,u,w,s,v,E),m=ya(a,(async()=>await h((async()=>{return await p(),a=(await g(o,c))[N]?.[l]??"null",aa(a,((a,t)=>"￼"===t?void 0:t));var a}))),(async a=>await h((async()=>{var t;await p(),await A(o,c,{[N]:{[l]:(t=a()??null,Z(t,((a,t)=>void 0===t?"￼":t)))}},!0,!0)}))),e,n,s,r,{[d]:()=>y,destroy:()=>(m.stopAutoLoad().stopAutoSave(),i(),m)},0,y);return m},pa=(a,t,e,n,s,i,r,[c,l,[u,w,y]],v,E,p,g,A,m,f,C)=>{const[S,b,T,O]=da(t,v,E,s,A,m,f,C),I=async(a,t)=>await d(na(l,(async([e,n,s,i],r)=>{t&&!(r in a)||await T(e,n,a[r],s,i,t)}))),L=async(a,t)=>w?await T(y,$,{[N]:a},!0,!0,t):null,D=ya(a,(async()=>await O((async()=>{await S();const a=await(async()=>G(h(await d(na(c,(async([a,t],e)=>[a,await b(e,t)]))),(a=>!X(a[1])))))(),t=await(async()=>u?(await b(y,$))[N]:{})();return X(a)&&o(t)?void 0:[a,t]}))),(async(a,t)=>await O((async()=>{if(await S(),o(t)){const[t,e]=a();await I(t),await L(e)}else await I(t[0],!0),await L(t[1],!0)}))),e,n,s,r,{[g]:()=>p,destroy:()=>(D.stopAutoLoad().stopAutoSave(),i(),D)},0,p);return D},ga="ColumnName",Aa="store",ha="json",ma=Aa+"TableName",fa=Aa+"Id"+ga,Na=Aa+ga,$a="autoLoadIntervalSeconds",Ca="rowId"+ga,Sa="tableId",ba="tableName",Ta="deleteEmptyColumns",Oa="deleteEmptyTable",Ia={mode:ha,[$a]:1},La={load:0,save:0,[ba]:t+"_values"},Da=(a,t,e,n,s)=>{const i=ta();return Q(a,((a,r)=>{const c=w(V(H(t,l(a)?{[e]:a}:a)),0,W(t));o(c[0])||n(r,c[0])||(s(r,c[0]),sa(i,r,c))})),i},Ra=(a,n,s,i,o,c,u,y,d,v,E="getDb",p)=>{let g,A,h;const m=((a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a)(s,c),[f,N,b,T]=(a=>{const e=(a=>H(Ia,l(a)?{[ma]:a}:a??{}))(a),n=e[$a];if(e.mode==ha){const a=e[ma]??t;return[1,n,[a,e[fa]??$,e[Na]??Aa],oa(a)]}const{tables:{load:s={},save:i={}}={},values:r={}}=e,o=w(V(H(La,r)),0,W(La)),c=o[2],u=oa(c),y=oa(c);return[0,n,[Da(s,{[Sa]:null,[Ca]:$},Sa,(a=>F(y,a)),(a=>ca(u,a))),Da(i,{[ba]:null,[Ca]:$,[Ta]:0,[Oa]:0},ba,((a,t)=>F(y,t)),((a,t)=>ca(u,t))),o],u]})(n);return(f?Ea:pa)(a,m,(a=>{let t;const e=()=>t=setInterval((async()=>{try{const[{d:t,s:e,c:n}]=await m(`${C} ${D} d,${R} s,TOTAL_CHANGES() c FROM ${L}${D} JOIN ${L}${R}`);t==g&&e==A&&n==h||(null!=g&&a(),g=t,A=e,h=n)}catch{}}),1e3*N),n=()=>{g=A=h=null,r(t)},s=i((t=>{T.has(t)&&(n(),a(),e())}));return e(),()=>{n(),o(s)}}),(a=>a()),u,y,d,b,j(T),(async(a,t)=>await a(`${C} t.name tn,c.name cn FROM ${M}list()t,${M}info(t.name)c ${S} t.schema='main'AND t.type IN('table','view')AND t.name IN(${P(t)})ORDER BY t.name,c.name`,t)),v,E,e,p,(a=>!0===a?1:!1===a?0:a),void 0)};exports.createElectricSqlPersister=(a,t,e,n,s)=>Ra(a,e,(async(a,e=[])=>await t.db.raw({sql:a,args:e})),(a=>t.notifier.subscribeToDataChanges((e=>E(t.notifier.alias(e),(({tablename:t})=>a(t)))))),(a=>a()),n,s,(()=>0),1,t,"getElectricClient");
