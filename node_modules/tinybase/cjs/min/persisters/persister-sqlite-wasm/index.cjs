"use strict";const t=t=>typeof t,a="tinybase",e="",n=",",s=t(e),i=Promise,r=clearInterval,o=t=>null==t,c=(t,a,e)=>o(t)?e?.():a(t),l=a=>t(a)==s,u=t=>Array.isArray(t),w=(t,a,e)=>t.slice(a,e),y=t=>t.length,d=async t=>i.all(t),p=t=>{throw Error(t)},v=(t,a)=>t.forEach(a),E=(t,a="")=>t.join(a),g=(t,a)=>t.map(a),h=t=>0==y(t),m=(t,a)=>t.filter(a),A=(t,...a)=>t.push(...a),N=t=>t.shift(),$="_",S="_id",f="SELECT",C="WHERE",O="TABLE",T="ALTER "+O,b="DELETE FROM",I=f+"*FROM",L="pragma_",R="data_version",D="schema_version",_="pragma_table_",M=t=>`"${t.replace(/"/g,'""')}"`,P=(t,a=[1])=>E(g(t,(()=>"$"+a[0]++)),n),F=(t,a)=>t?.has(a)??!1,j=t=>o(t)||0==(t=>t?.size??0)(t),k=t=>[...t?.values()??[]],U=(t,a)=>t?.forEach(a),q=(t,a)=>t?.delete(a),x=Object,B=t=>x.getPrototypeOf(t),J=x.entries,Y=x.keys,z=x.freeze,G=(t=[])=>x.fromEntries(t),H=(...t)=>x.assign({},...t),V=(t,a)=>(delete t[a],t),W=(t,a)=>g(J(t),(([t,e])=>a(e,t))),K=t=>x.values(t),Q=t=>y(Y(t)),X=t=>(t=>!o(t)&&c(B(t),(t=>t==x.prototype||o(B(t))),(()=>!0)))(t)&&0==Q(t),Z=JSON.stringify,tt=JSON.parse,at=t=>new Map(t),et=(t,a)=>t?.get(a),nt=(t,a)=>g([...t?.entries()??[]],(([t,e])=>a(e,t))),st=(t,a,e)=>o(e)?(q(t,a),t):t?.set(a,e),it=(t,a,e,n)=>(F(t,a)?n?.(et(t,a)):st(t,a,e()),et(t,a)),rt=(t,a,e,n,s=0)=>c((e?it:et)(t,a[s],s>y(a)-2?e:at),(i=>{if(s>y(a)-2)return n?.(i)&&st(t,a[s]),i;const r=rt(i,a,e,n,s+1);return j(i)&&st(t,a[s]),r})),ot=t=>new Set(u(t)||o(t)?t:[t]),ct=(t,a)=>t?.add(a),lt=/^\d+$/,ut=at(),wt=at(),yt=(t,a,n,s,i,r,l,w={},d=0,E=[])=>{let g,h,m,$=0,S=0,f=0;it(ut,E,(()=>0)),it(wt,E,(()=>[]));const C=at(),[O,T,b,I,L]=((t=1,a,e)=>1!=t&&a.isMergeable()?[1,a.getMergeableContent,()=>a.getTransactionMergeableChanges(!e),([[t],[a]])=>!X(t)||!X(a),a.setDefaultContent]:2!=t?[0,a.getContent,a.getTransactionChanges,([t,a])=>!X(t)||!X(a),a.setContent]:p("Store type not supported by this Persister"))(l,t,d),[R,D,_]=(()=>{let t;const[a,n]=(()=>{const t=[];let a=0;return[n=>(n?N(t):null)??e+a++,a=>{lt.test(a)&&y(t)<1e3&&A(t,a)}]})(),s=at();return[(n,i,r,o=[],c=()=>[])=>{t??=Y;const l=a(1);return st(s,l,[n,i,r,o,c]),ct(rt(i,r??[e],ot),l),l},(a,n,...i)=>v(((t,a=[e])=>{const n=[],s=(t,e)=>e==y(a)?A(n,t):null===a[e]?U(t,(t=>s(t,e+1))):v([a[e],null],(a=>s(et(t,a),e+1)));return s(t,0),n})(a,n),(a=>U(a,(a=>et(s,a)[0](t,...n??[],...i))))),t=>c(et(s,t),(([,a,i])=>(rt(a,i??[e],void 0,(a=>(q(a,t),j(a)?1:0))),st(s,t),n(t),i))),a=>c(et(s,a),(([a,,e=[],n,s])=>{const i=(...r)=>{const c=y(r);c==y(e)?a(t,...r,...s(r)):o(e[c])?v(n[c]?.(...r)??[],(t=>i(...r,t))):i(...r,e[c])};i()}))]})(),M=t=>{t!=$&&($=t,D(C,void 0,$))},P=a=>{(O&&u(a?.[0])?1===a?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===a?.[2]?t.applyChanges:t.setContent)(a)},F=async t=>(2!=$&&(M(1),S++,await J((async()=>{try{const e=await a();u(e)?P(e):t?L(t):p("Content is not an array: "+e)}catch(a){r?.(a),t&&L(t)}M(0)}))),Y),k=()=>(h&&(i(h),h=void 0),Y),x=async t=>(1!=$&&(M(2),f++,await J((async()=>{try{await n(T,t)}catch(t){r?.(t)}M(0)}))),Y),B=()=>(m&&(t.delListener(m),m=void 0),Y),J=async(...t)=>(A(et(wt,E),...t),await(async()=>{if(!et(ut,E)){for(st(ut,E,1);!o(g=N(et(wt,E)));)try{await g()}catch(t){r?.(t)}st(ut,E,0)}})(),Y),Y={load:F,startAutoLoad:async t=>{k(),await F(t);try{h=await s((async(t,a)=>{a||t?2!=$&&(M(1),S++,P(a??t),M(0)):await F()}))}catch(t){r?.(t)}return Y},stopAutoLoad:k,isAutoLoading:()=>!o(h),save:x,startAutoSave:async()=>(B(),await x(),m=t.addDidFinishTransactionListener((()=>{const t=b();I(t)&&x(t)})),Y),stopAutoSave:B,isAutoSaving:()=>!o(m),getStatus:()=>$,addStatusListener:t=>R(t,C),delListener:a=>(_(a),t),schedule:J,getStore:()=>t,destroy:()=>(et(wt,E).splice(0,void 0),k().stopAutoSave()),getStats:()=>({loads:S,saves:f}),...w};return z(Y)},dt=(t,a,e,s,i,r=pt,c,l)=>{const u=at();return[async()=>{u.clear(),g(await e(t,a),(({tn:t,cn:a})=>ct(it(u,t,ot),a)))},async(a,e)=>((t,a)=>F(et(u,t),a))(a,e)?G(m(g(await t(I+M(a)),(t=>{return[t[e],l?(a=V(t,e),n=l,G(W(a,((t,a)=>[a,n(t,a)])))):V(t,e)];var a,n})),(([t,a])=>!o(t)&&!X(a)))):{},async(a,e,s,l,w,y=!1)=>{const p=ot();W(s??{},(t=>g(Y(t??{}),(t=>ct(p,t)))));const v=k(p);if(!y&&w&&h(v)&&F(u,a))return await t("DROP "+O+M(a)),void st(u,a);const N=et(u,a),$=ot(k(N));if(h(v)||(F(u,a)?await d(g([e,...v],(async(n,s)=>{q($,n)||(await t(T+M(a)+"ADD"+M(n)+i),0==s&&await t("CREATE UNIQUE INDEX pk ON "+M(a)+`(${M(e)})`),ct(N,n))}))):(await t("CREATE "+O+M(a)+`(${M(e)}${i} PRIMARY KEY${E(g(v,(t=>n+M(t)+i)))});`),st(u,a,ot([e,...v])))),await d([...!y&&l?g(k($),(async n=>{n!=e&&(await t(T+M(a)+"DROP"+M(n)),q(N,n))})):[]]),y)o(s)?await t(b+M(a)+C+" true"):await d(W(s,(async(n,s)=>{o(n)?await t(b+M(a)+C+M(e)+"=$1",[s]):h(v)||await r(t,a,e,Y(n),{[s]:c?g(K(n),c):K(n)},N)})));else if(h(v))F(u,a)&&await t(b+M(a)+C+" true");else{const n=m(k(et(u,a)),(t=>t!=e)),i={},o=[];W(s??{},((t,a)=>{i[a]=g(n,(a=>c?c(t?.[a]):t?.[a])),A(o,a)})),await r(t,a,e,n,i),await t(b+M(a)+C+M(e)+`NOT IN(${P(o)})`,o)}},async a=>{let e;await t("BEGIN");try{e=await a()}catch(t){s?.(t)}return await t("END"),e}]},pt=async(t,a,e,s,i)=>{const r=[1];await t("INSERT INTO"+M(a)+"("+((...t)=>E(g(t,M),n))(e,...s)+")VALUES"+E(W(i,(t=>"($"+r[0]+++","+P(t,r)+")")),n)+"ON CONFLICT("+M(e)+")DO UPDATE SET"+E(g(s,(t=>M(t)+"=excluded."+M(t))),n),W(i,((t,a)=>[a,...g(t,(t=>t??null))])).flat())},vt=(t,a,e,n,s,i,r,[o,c,l],u,w,y,d,p,v)=>{const[E,g,h,m]=dt(a,u,w,s,p,v),A=yt(t,(async()=>await m((async()=>{return await E(),t=(await g(o,c))[$]?.[l]??"null",tt(t,((t,a)=>"ï¿¼"===a?void 0:a));var t}))),(async t=>await m((async()=>{var a;await E(),await h(o,c,{[$]:{[l]:(a=t()??null,Z(a,((t,a)=>void 0===a?"ï¿¼":a)))}},!0,!0)}))),e,n,s,r,{[d]:()=>y,destroy:()=>(A.stopAutoLoad().stopAutoSave(),i(),A)},0,y);return A},Et=(t,a,e,n,s,i,r,[c,l,[u,w,y]],p,v,E,g,h,A,N,f)=>{const[C,O,T,b]=dt(a,p,v,s,h,A,N,f),I=async(t,a)=>await d(nt(l,(async([e,n,s,i],r)=>{a&&!(r in t)||await T(e,n,t[r],s,i,a)}))),L=async(t,a)=>w?await T(y,S,{[$]:t},!0,!0,a):null,R=yt(t,(async()=>await b((async()=>{await C();const t=await(async()=>G(m(await d(nt(c,(async([t,a],e)=>[t,await O(e,a)]))),(t=>!X(t[1])))))(),a=await(async()=>u?(await O(y,S))[$]:{})();return X(t)&&o(a)?void 0:[t,a]}))),(async(t,a)=>await b((async()=>{if(await C(),o(a)){const[a,e]=t();await I(a),await L(e)}else await I(a[0],!0),await L(a[1],!0)}))),e,n,s,r,{[g]:()=>E,destroy:()=>(R.stopAutoLoad().stopAutoSave(),i(),R)},0,E);return R},gt="ColumnName",ht="store",mt="json",At=ht+"TableName",Nt=ht+"Id"+gt,$t=ht+gt,St="autoLoadIntervalSeconds",ft="rowId"+gt,Ct="tableId",Ot="tableName",Tt="deleteEmptyColumns",bt="deleteEmptyTable",It={mode:mt,[St]:1},Lt={load:0,save:0,[Ot]:a+"_values"},Rt=(t,a,e,n,s)=>{const i=at();return W(t,((t,r)=>{const c=w(K(H(a,l(t)?{[e]:t}:t)),0,Q(a));o(c[0])||n(r,c[0])||(s(r,c[0]),st(i,r,c))})),i},Dt=(t,n,s,i,o,c,u,y,d,p,v="getDb",E)=>{let g,h,m;const A=((t,a)=>a?async(e,n)=>(a(e,n),await t(e,n)):t)(s,c),[N,$,O,T]=(t=>{const e=(t=>H(It,l(t)?{[At]:t}:t??{}))(t),n=e[St];if(e.mode==mt){const t=e[At]??a;return[1,n,[t,e[Nt]??S,e[$t]??ht],ot(t)]}const{tables:{load:s={},save:i={}}={},values:r={}}=e,o=w(K(H(Lt,r)),0,Q(Lt)),c=o[2],u=ot(c),y=ot(c);return[0,n,[Rt(s,{[Ct]:null,[ft]:S},Ct,(t=>F(y,t)),(t=>ct(u,t))),Rt(i,{[Ot]:null,[ft]:S,[Tt]:0,[bt]:0},Ot,((t,a)=>F(y,a)),((t,a)=>ct(u,a))),o],u]})(n);return(N?vt:Et)(t,A,(t=>{let a;const e=()=>a=setInterval((async()=>{try{const[{d:a,s:e,c:n}]=await A(`${f} ${R} d,${D} s,TOTAL_CHANGES() c FROM ${L}${R} JOIN ${L}${D}`);a==g&&e==h&&n==m||(null!=g&&t(),g=a,h=e,m=n)}catch{}}),1e3*$),n=()=>{g=h=m=null,r(a)},s=i((a=>{T.has(a)&&(n(),t(),e())}));return e(),()=>{n(),o(s)}}),(t=>t()),u,y,d,O,k(T),(async(t,a)=>await t(`${f} t.name tn,c.name cn FROM ${_}list()t,${_}info(t.name)c ${C} t.schema='main'AND t.type IN('table','view')AND t.name IN(${P(a)})ORDER BY t.name,c.name`,a)),p,v,e,E,(t=>!0===t?1:!1===t?0:t),void 0)};exports.createSqliteWasmPersister=(t,a,e,n,s,i)=>Dt(t,n,(async(t,a=[])=>e.exec(t,{bind:a,rowMode:"object",returnValue:"resultRows"}).map((t=>({...t})))),(t=>a.capi.sqlite3_update_hook(e,((a,e,n,s)=>t(s)),0)),(()=>a.capi.sqlite3_update_hook(e,(()=>0),0)),s,i,(()=>0),3,e);
