"use strict";const t=t=>typeof t,a="tinybase",e="",n=",",s=t(e),i=Promise,r=clearInterval,o=t=>null==t,c=(t,a,e)=>o(t)?e?.():a(t),l=a=>t(a)==s,u=t=>Array.isArray(t),w=(t,a,e)=>t.slice(a,e),y=t=>t.length,d=async t=>i.all(t),v=t=>{throw Error(t)},p=(t,a)=>t.forEach(a),E=(t,a="")=>t.join(a),g=(t,a)=>t.map(a),A=t=>0==y(t),h=(t,a)=>t.filter(a),m=(t,...a)=>t.push(...a),N=t=>t.shift(),$="_",S="_id",f="SELECT",C="WHERE",O="TABLE",T="ALTER "+O,L="DELETE FROM",b=f+"*FROM",I="pragma_",D="data_version",R="schema_version",M="pragma_table_",_=t=>`"${t.replace(/"/g,'""')}"`,P=(t,a=[1])=>E(g(t,(()=>"$"+a[0]++)),n),F=(t,a)=>t?.has(a)??!1,U=t=>o(t)||0==(t=>t?.size??0)(t),j=t=>[...t?.values()??[]],x=(t,a)=>t?.forEach(a),B=(t,a)=>t?.delete(a),J=Object,Y=t=>J.getPrototypeOf(t),k=J.entries,q=J.keys,z=J.freeze,G=(t=[])=>J.fromEntries(t),H=(...t)=>J.assign({},...t),K=(t,a)=>(delete t[a],t),Q=(t,a)=>g(k(t),(([t,e])=>a(e,t))),V=t=>J.values(t),W=t=>y(q(t)),X=t=>(t=>!o(t)&&c(Y(t),(t=>t==J.prototype||o(Y(t))),(()=>!0)))(t)&&0==W(t),Z=JSON.stringify,tt=JSON.parse,at=t=>new Map(t),et=(t,a)=>t?.get(a),nt=(t,a)=>g([...t?.entries()??[]],(([t,e])=>a(e,t))),st=(t,a,e)=>o(e)?(B(t,a),t):t?.set(a,e),it=(t,a,e,n)=>(F(t,a)?n?.(et(t,a)):st(t,a,e()),et(t,a)),rt=(t,a,e,n,s=0)=>c((e?it:et)(t,a[s],s>y(a)-2?e:at),(i=>{if(s>y(a)-2)return n?.(i)&&st(t,a[s]),i;const r=rt(i,a,e,n,s+1);return U(i)&&st(t,a[s]),r})),ot=t=>new Set(u(t)||o(t)?t:[t]),ct=(t,a)=>t?.add(a),lt=/^\d+$/,ut=at(),wt=at(),yt=(t,a,n,s,i,r,l,w={},d=0,E=[])=>{let g,A,h,$=0,S=0,f=0;it(ut,E,(()=>0)),it(wt,E,(()=>[]));const C=at(),[O,T,L,b,I]=((t=1,a,e)=>1!=t&&a.isMergeable()?[1,a.getMergeableContent,()=>a.getTransactionMergeableChanges(!e),([[t],[a]])=>!X(t)||!X(a),a.setDefaultContent]:2!=t?[0,a.getContent,a.getTransactionChanges,([t,a])=>!X(t)||!X(a),a.setContent]:v("Store type not supported by this Persister"))(l,t,d),[D,R,M]=(()=>{let t;const[a,n]=(()=>{const t=[];let a=0;return[n=>(n?N(t):null)??e+a++,a=>{lt.test(a)&&y(t)<1e3&&m(t,a)}]})(),s=at();return[(n,i,r,o=[],c=()=>[])=>{t??=q;const l=a(1);return st(s,l,[n,i,r,o,c]),ct(rt(i,r??[e],ot),l),l},(a,n,...i)=>p(((t,a=[e])=>{const n=[],s=(t,e)=>e==y(a)?m(n,t):null===a[e]?x(t,(t=>s(t,e+1))):p([a[e],null],(a=>s(et(t,a),e+1)));return s(t,0),n})(a,n),(a=>x(a,(a=>et(s,a)[0](t,...n??[],...i))))),t=>c(et(s,t),(([,a,i])=>(rt(a,i??[e],void 0,(a=>(B(a,t),U(a)?1:0))),st(s,t),n(t),i))),a=>c(et(s,a),(([a,,e=[],n,s])=>{const i=(...r)=>{const c=y(r);c==y(e)?a(t,...r,...s(r)):o(e[c])?p(n[c]?.(...r)??[],(t=>i(...r,t))):i(...r,e[c])};i()}))]})(),_=t=>{t!=$&&($=t,R(C,void 0,$))},P=a=>{(O&&u(a?.[0])?1===a?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===a?.[2]?t.applyChanges:t.setContent)(a)},F=async t=>(2!=$&&(_(1),S++,await k((async()=>{try{const e=await a();u(e)?P(e):t?I(t):v("Content is not an array: "+e)}catch(a){r?.(a),t&&I(t)}_(0)}))),q),j=()=>(A&&(i(A),A=void 0),q),J=async t=>(1!=$&&(_(2),f++,await k((async()=>{try{await n(T,t)}catch(t){r?.(t)}_(0)}))),q),Y=()=>(h&&(t.delListener(h),h=void 0),q),k=async(...t)=>(m(et(wt,E),...t),await(async()=>{if(!et(ut,E)){for(st(ut,E,1);!o(g=N(et(wt,E)));)try{await g()}catch(t){r?.(t)}st(ut,E,0)}})(),q),q={load:F,startAutoLoad:async t=>{j(),await F(t);try{A=await s((async(t,a)=>{a||t?2!=$&&(_(1),S++,P(a??t),_(0)):await F()}))}catch(t){r?.(t)}return q},stopAutoLoad:j,isAutoLoading:()=>!o(A),save:J,startAutoSave:async()=>(Y(),await J(),h=t.addDidFinishTransactionListener((()=>{const t=L();b(t)&&J(t)})),q),stopAutoSave:Y,isAutoSaving:()=>!o(h),getStatus:()=>$,addStatusListener:t=>D(t,C),delListener:a=>(M(a),t),schedule:k,getStore:()=>t,destroy:()=>(et(wt,E).splice(0,void 0),j().stopAutoSave()),getStats:()=>({loads:S,saves:f}),...w};return z(q)},dt=(t,a,e,s,i,r=vt,c,l)=>{const u=at();return[async()=>{u.clear(),g(await e(t,a),(({tn:t,cn:a})=>ct(it(u,t,ot),a)))},async(a,e)=>((t,a)=>F(et(u,t),a))(a,e)?G(h(g(await t(b+_(a)),(t=>{return[t[e],l?(a=K(t,e),n=l,G(Q(a,((t,a)=>[a,n(t,a)])))):K(t,e)];var a,n})),(([t,a])=>!o(t)&&!X(a)))):{},async(a,e,s,l,w,y=!1)=>{const v=ot();Q(s??{},(t=>g(q(t??{}),(t=>ct(v,t)))));const p=j(v);if(!y&&w&&A(p)&&F(u,a))return await t("DROP "+O+_(a)),void st(u,a);const N=et(u,a),$=ot(j(N));if(A(p)||(F(u,a)?await d(g([e,...p],(async(n,s)=>{B($,n)||(await t(T+_(a)+"ADD"+_(n)+i),0==s&&await t("CREATE UNIQUE INDEX pk ON "+_(a)+`(${_(e)})`),ct(N,n))}))):(await t("CREATE "+O+_(a)+`(${_(e)}${i} PRIMARY KEY${E(g(p,(t=>n+_(t)+i)))});`),st(u,a,ot([e,...p])))),await d([...!y&&l?g(j($),(async n=>{n!=e&&(await t(T+_(a)+"DROP"+_(n)),B(N,n))})):[]]),y)o(s)?await t(L+_(a)+C+" true"):await d(Q(s,(async(n,s)=>{o(n)?await t(L+_(a)+C+_(e)+"=$1",[s]):A(p)||await r(t,a,e,q(n),{[s]:c?g(V(n),c):V(n)},N)})));else if(A(p))F(u,a)&&await t(L+_(a)+C+" true");else{const n=h(j(et(u,a)),(t=>t!=e)),i={},o=[];Q(s??{},((t,a)=>{i[a]=g(n,(a=>c?c(t?.[a]):t?.[a])),m(o,a)})),await r(t,a,e,n,i),await t(L+_(a)+C+_(e)+`NOT IN(${P(o)})`,o)}},async a=>{let e;await t("BEGIN");try{e=await a()}catch(t){s?.(t)}return await t("END"),e}]},vt=async(t,a,e,s,i)=>{const r=[1];await t("INSERT INTO"+_(a)+"("+((...t)=>E(g(t,_),n))(e,...s)+")VALUES"+E(Q(i,(t=>"($"+r[0]+++","+P(t,r)+")")),n)+"ON CONFLICT("+_(e)+")DO UPDATE SET"+E(g(s,(t=>_(t)+"=excluded."+_(t))),n),Q(i,((t,a)=>[a,...g(t,(t=>t??null))])).flat())},pt=(t,a,e,n,s,i,r,[o,c,l],u,w,y,d,v,p)=>{const[E,g,A,h]=dt(a,u,w,s,v,p),m=yt(t,(async()=>await h((async()=>{return await E(),t=(await g(o,c))[$]?.[l]??"null",tt(t,((t,a)=>"ï¿¼"===a?void 0:a));var t}))),(async t=>await h((async()=>{var a;await E(),await A(o,c,{[$]:{[l]:(a=t()??null,Z(a,((t,a)=>void 0===a?"ï¿¼":a)))}},!0,!0)}))),e,n,s,r,{[d]:()=>y,destroy:()=>(m.stopAutoLoad().stopAutoSave(),i(),m)},0,y);return m},Et=(t,a,e,n,s,i,r,[c,l,[u,w,y]],v,p,E,g,A,m,N,f)=>{const[C,O,T,L]=dt(a,v,p,s,A,m,N,f),b=async(t,a)=>await d(nt(l,(async([e,n,s,i],r)=>{a&&!(r in t)||await T(e,n,t[r],s,i,a)}))),I=async(t,a)=>w?await T(y,S,{[$]:t},!0,!0,a):null,D=yt(t,(async()=>await L((async()=>{await C();const t=await(async()=>G(h(await d(nt(c,(async([t,a],e)=>[t,await O(e,a)]))),(t=>!X(t[1])))))(),a=await(async()=>u?(await O(y,S))[$]:{})();return X(t)&&o(a)?void 0:[t,a]}))),(async(t,a)=>await L((async()=>{if(await C(),o(a)){const[a,e]=t();await b(a),await I(e)}else await b(a[0],!0),await I(a[1],!0)}))),e,n,s,r,{[g]:()=>E,destroy:()=>(D.stopAutoLoad().stopAutoSave(),i(),D)},0,E);return D},gt="ColumnName",At="store",ht="json",mt=At+"TableName",Nt=At+"Id"+gt,$t=At+gt,St="autoLoadIntervalSeconds",ft="rowId"+gt,Ct="tableId",Ot="tableName",Tt="deleteEmptyColumns",Lt="deleteEmptyTable",bt={mode:ht,[St]:1},It={load:0,save:0,[Ot]:a+"_values"},Dt=(t,a,e,n,s)=>{const i=at();return Q(t,((t,r)=>{const c=w(V(H(a,l(t)?{[e]:t}:t)),0,W(a));o(c[0])||n(r,c[0])||(s(r,c[0]),st(i,r,c))})),i},Rt=(t,n,s,i,o,c,u,y,d,v,p="getDb",E)=>{let g,A,h;const m=((t,a)=>a?async(e,n)=>(a(e,n),await t(e,n)):t)(s,c),[N,$,O,T]=(t=>{const e=(t=>H(bt,l(t)?{[mt]:t}:t??{}))(t),n=e[St];if(e.mode==ht){const t=e[mt]??a;return[1,n,[t,e[Nt]??S,e[$t]??At],ot(t)]}const{tables:{load:s={},save:i={}}={},values:r={}}=e,o=w(V(H(It,r)),0,W(It)),c=o[2],u=ot(c),y=ot(c);return[0,n,[Dt(s,{[Ct]:null,[ft]:S},Ct,(t=>F(y,t)),(t=>ct(u,t))),Dt(i,{[Ot]:null,[ft]:S,[Tt]:0,[Lt]:0},Ot,((t,a)=>F(y,a)),((t,a)=>ct(u,a))),o],u]})(n);return(N?pt:Et)(t,m,(t=>{let a;const e=()=>a=setInterval((async()=>{try{const[{d:a,s:e,c:n}]=await m(`${f} ${D} d,${R} s,TOTAL_CHANGES() c FROM ${I}${D} JOIN ${I}${R}`);a==g&&e==A&&n==h||(null!=g&&t(),g=a,A=e,h=n)}catch{}}),1e3*$),n=()=>{g=A=h=null,r(a)},s=i((a=>{T.has(a)&&(n(),t(),e())}));return e(),()=>{n(),o(s)}}),(t=>t()),u,y,d,O,j(T),(async(t,a)=>await t(`${f} t.name tn,c.name cn FROM ${M}list()t,${M}info(t.name)c ${C} t.schema='main'AND t.type IN('table','view')AND t.name IN(${P(a)})ORDER BY t.name,c.name`,a)),v,p,e,E,(t=>!0===t?1:!1===t?0:t),void 0)};exports.createLibSqlPersister=(t,a,e,n,s)=>Rt(t,e,(async(t,e=[])=>(await a.execute({sql:t,args:e})).rows),(()=>()=>0),(t=>t()),n,s,(()=>0),1,a,"getClient");
