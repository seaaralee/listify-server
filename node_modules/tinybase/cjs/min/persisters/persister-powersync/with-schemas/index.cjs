"use strict";const a=a=>typeof a,t="tinybase",e="",n=",",s=a(e),r=Promise,o=clearInterval,i=a=>null==a,c=(a,t,e)=>i(a)?e?.():t(a),l=t=>a(t)==s,w=a=>Array.isArray(a),u=(a,t,e)=>a.slice(t,e),y=a=>a.length,d=async a=>r.all(a),E=a=>{throw Error(a)},v=(a,t)=>a.forEach(t),g=(a,t="")=>a.join(t),p=(a,t)=>a.map(t),A=a=>0==y(a),h=(a,t)=>a.filter(t),N=(a,...t)=>a.push(...t),S=a=>a.shift(),f=Object,m=a=>f.getPrototypeOf(a),T=f.entries,C=f.keys,$=f.freeze,O=(a=[])=>f.fromEntries(a),b=(...a)=>f.assign({},...a),I=(a,t)=>(delete a[t],a),L=(a,t)=>p(T(a),(([a,e])=>t(e,a))),R=a=>f.values(a),D=a=>y(C(a)),M=a=>(a=>!i(a)&&c(m(a),(a=>a==f.prototype||i(m(a))),(()=>!0)))(a)&&0==D(a),P=a=>new Set(w(a)||i(a)?a:[a]),_=(a,t)=>a?.add(t),F="_",U="_id",j="SELECT",x="WHERE",B="TABLE",H="ALTER "+B,J="DELETE FROM",Y=j+"*FROM",k="pragma_",z="data_version",G="schema_version",V="pragma_table_",W=a=>`"${a.replace(/"/g,'""')}"`,K=(...a)=>g(p(a,W),n),Q=(a,t=[1])=>g(p(a,(()=>"$"+t[0]++)),n),X=(a,t)=>a?.has(t)??!1,q=a=>i(a)||0==(a=>a?.size??0)(a),Z=a=>[...a?.values()??[]],aa=(a,t)=>a?.forEach(t),ta=(a,t)=>a?.delete(t),ea=JSON.stringify,na=JSON.parse,sa=a=>new Map(a),ra=(a,t)=>a?.get(t),oa=(a,t)=>p([...a?.entries()??[]],(([a,e])=>t(e,a))),ia=(a,t,e)=>i(e)?(ta(a,t),a):a?.set(t,e),ca=(a,t,e,n)=>(X(a,t)?n?.(ra(a,t)):ia(a,t,e()),ra(a,t)),la=(a,t,e,n,s=0)=>c((e?ca:ra)(a,t[s],s>y(t)-2?e:sa),(r=>{if(s>y(t)-2)return n?.(r)&&ia(a,t[s]),r;const o=la(r,t,e,n,s+1);return q(r)&&ia(a,t[s]),o})),wa=/^\d+$/,ua=sa(),ya=sa(),da=(a,t,n,s,r,o,l,u={},d=0,g=[])=>{let p,A,h,f=0,m=0,T=0;ca(ua,g,(()=>0)),ca(ya,g,(()=>[]));const C=sa(),[O,b,I,L,R]=((a=1,t,e)=>1!=a&&t.isMergeable()?[1,t.getMergeableContent,()=>t.getTransactionMergeableChanges(!e),([[a],[t]])=>!M(a)||!M(t),t.setDefaultContent]:2!=a?[0,t.getContent,t.getTransactionChanges,([a,t])=>!M(a)||!M(t),t.setContent]:E("Store type not supported by this Persister"))(l,a,d),[D,F,U]=(()=>{let a;const[t,n]=(()=>{const a=[];let t=0;return[n=>(n?S(a):null)??e+t++,t=>{wa.test(t)&&y(a)<1e3&&N(a,t)}]})(),s=sa();return[(n,r,o,i=[],c=()=>[])=>{a??=z;const l=t(1);return ia(s,l,[n,r,o,i,c]),_(la(r,o??[e],P),l),l},(t,n,...r)=>v(((a,t=[e])=>{const n=[],s=(a,e)=>e==y(t)?N(n,a):null===t[e]?aa(a,(a=>s(a,e+1))):v([t[e],null],(t=>s(ra(a,t),e+1)));return s(a,0),n})(t,n),(t=>aa(t,(t=>ra(s,t)[0](a,...n??[],...r))))),a=>c(ra(s,a),(([,t,r])=>(la(t,r??[e],void 0,(t=>(ta(t,a),q(t)?1:0))),ia(s,a),n(a),r))),t=>c(ra(s,t),(([t,,e=[],n,s])=>{const r=(...o)=>{const c=y(o);c==y(e)?t(a,...o,...s(o)):i(e[c])?v(n[c]?.(...o)??[],(a=>r(...o,a))):r(...o,e[c])};r()}))]})(),j=a=>{a!=f&&(f=a,F(C,void 0,f))},x=t=>{(O&&w(t?.[0])?1===t?.[2]?a.applyMergeableChanges:a.setMergeableContent:1===t?.[2]?a.applyChanges:a.setContent)(t)},B=async a=>(2!=f&&(j(1),m++,await k((async()=>{try{const e=await t();w(e)?x(e):a?R(a):E("Content is not an array: "+e)}catch(t){o?.(t),a&&R(a)}j(0)}))),z),H=()=>(A&&(r(A),A=void 0),z),J=async a=>(1!=f&&(j(2),T++,await k((async()=>{try{await n(b,a)}catch(a){o?.(a)}j(0)}))),z),Y=()=>(h&&(a.delListener(h),h=void 0),z),k=async(...a)=>(N(ra(ya,g),...a),await(async()=>{if(!ra(ua,g)){for(ia(ua,g,1);!i(p=S(ra(ya,g)));)try{await p()}catch(a){o?.(a)}ia(ua,g,0)}})(),z),z={load:B,startAutoLoad:async a=>{H(),await B(a);try{A=await s((async(a,t)=>{t||a?2!=f&&(j(1),m++,x(t??a),j(0)):await B()}))}catch(a){o?.(a)}return z},stopAutoLoad:H,isAutoLoading:()=>!i(A),save:J,startAutoSave:async()=>(Y(),await J(),h=a.addDidFinishTransactionListener((()=>{const a=I();L(a)&&J(a)})),z),stopAutoSave:Y,isAutoSaving:()=>!i(h),getStatus:()=>f,addStatusListener:a=>D(a,C),delListener:t=>(U(t),a),schedule:k,getStore:()=>a,destroy:()=>(ra(ya,g).splice(0,void 0),H().stopAutoSave()),getStats:()=>({loads:m,saves:T}),...u};return $(z)},Ea=(a,t,e,s,r,o=va,c,l)=>{const w=sa();return[async()=>{w.clear(),p(await e(a,t),(({tn:a,cn:t})=>_(ca(w,a,P),t)))},async(t,e)=>((a,t)=>X(ra(w,a),t))(t,e)?O(h(p(await a(Y+W(t)),(a=>{return[a[e],l?(t=I(a,e),n=l,O(L(t,((a,t)=>[t,n(a,t)])))):I(a,e)];var t,n})),(([a,t])=>!i(a)&&!M(t)))):{},async(t,e,s,l,u,y=!1)=>{const E=P();L(s??{},(a=>p(C(a??{}),(a=>_(E,a)))));const v=Z(E);if(!y&&u&&A(v)&&X(w,t))return await a("DROP "+B+W(t)),void ia(w,t);const S=ra(w,t),f=P(Z(S));if(A(v)||(X(w,t)?await d(p([e,...v],(async(n,s)=>{ta(f,n)||(await a(H+W(t)+"ADD"+W(n)+r),0==s&&await a("CREATE UNIQUE INDEX pk ON "+W(t)+`(${W(e)})`),_(S,n))}))):(await a("CREATE "+B+W(t)+`(${W(e)}${r} PRIMARY KEY${g(p(v,(a=>n+W(a)+r)))});`),ia(w,t,P([e,...v])))),await d([...!y&&l?p(Z(f),(async n=>{n!=e&&(await a(H+W(t)+"DROP"+W(n)),ta(S,n))})):[]]),y)i(s)?await a(J+W(t)+x+" true"):await d(L(s,(async(n,s)=>{i(n)?await a(J+W(t)+x+W(e)+"=$1",[s]):A(v)||await o(a,t,e,C(n),{[s]:c?p(R(n),c):R(n)},S)})));else if(A(v))X(w,t)&&await a(J+W(t)+x+" true");else{const n=h(Z(ra(w,t)),(a=>a!=e)),r={},i=[];L(s??{},((a,t)=>{r[t]=p(n,(t=>c?c(a?.[t]):a?.[t])),N(i,t)})),await o(a,t,e,n,r),await a(J+W(t)+x+W(e)+`NOT IN(${Q(i)})`,i)}},async t=>{let e;await a("BEGIN");try{e=await t()}catch(a){s?.(a)}return await a("END"),e}]},va=async(a,t,e,s,r)=>{const o=[1];await a("INSERT INTO"+W(t)+"("+K(e,...s)+")VALUES"+g(L(r,(a=>"($"+o[0]+++","+Q(a,o)+")")),n)+"ON CONFLICT("+W(e)+")DO UPDATE SET"+g(p(s,(a=>W(a)+"=excluded."+W(a))),n),L(r,((a,t)=>[t,...p(a,(a=>a??null))])).flat())},ga=(a,t,e,n,s,r,o,[i,c,l],w,u,y,d,E,v)=>{const[g,p,A,h]=Ea(t,w,u,s,E,v),N=da(a,(async()=>await h((async()=>{return await g(),a=(await p(i,c))[F]?.[l]??"null",na(a,((a,t)=>"￼"===t?void 0:t));var a}))),(async a=>await h((async()=>{var t;await g(),await A(i,c,{[F]:{[l]:(t=a()??null,ea(t,((a,t)=>void 0===t?"￼":t)))}},!0,!0)}))),e,n,s,o,{[d]:()=>y,destroy:()=>(N.stopAutoLoad().stopAutoSave(),r(),N)},0,y);return N},pa=(a,t,e,n,s,r,o,[c,l,[w,u,y]],E,v,g,p,A,N,S,f)=>{const[m,T,C,$]=Ea(t,E,v,s,A,N,S,f),b=async(a,t)=>await d(oa(l,(async([e,n,s,r],o)=>{t&&!(o in a)||await C(e,n,a[o],s,r,t)}))),I=async(a,t)=>u?await C(y,U,{[F]:a},!0,!0,t):null,L=da(a,(async()=>await $((async()=>{await m();const a=await(async()=>O(h(await d(oa(c,(async([a,t],e)=>[a,await T(e,t)]))),(a=>!M(a[1])))))(),t=await(async()=>w?(await T(y,U))[F]:{})();return M(a)&&i(t)?void 0:[a,t]}))),(async(a,t)=>await $((async()=>{if(await m(),i(t)){const[t,e]=a();await b(t),await I(e)}else await b(t[0],!0),await I(t[1],!0)}))),e,n,s,o,{[p]:()=>g,destroy:()=>(L.stopAutoLoad().stopAutoSave(),r(),L)},0,g);return L},Aa="ColumnName",ha="store",Na="json",Sa=ha+"TableName",fa=ha+"Id"+Aa,ma=ha+Aa,Ta="autoLoadIntervalSeconds",Ca="rowId"+Aa,$a="tableId",Oa="tableName",ba="deleteEmptyColumns",Ia="deleteEmptyTable",La={mode:Na,[Ta]:1},Ra={load:0,save:0,[Oa]:t+"_values"},Da=(a,t,e,n,s)=>{const r=sa();return L(a,((a,o)=>{const c=u(R(b(t,l(a)?{[e]:a}:a)),0,D(t));i(c[0])||n(o,c[0])||(s(o,c[0]),ia(r,o,c))})),r},Ma=(a,n,s,r,i,c,w,y,d,E,v="getDb",g)=>{let p,A,h;const N=((a,t)=>t?async(e,n)=>(t(e,n),await a(e,n)):a)(s,c),[S,f,m,T]=(a=>{const e=(a=>b(La,l(a)?{[Sa]:a}:a??{}))(a),n=e[Ta];if(e.mode==Na){const a=e[Sa]??t;return[1,n,[a,e[fa]??U,e[ma]??ha],P(a)]}const{tables:{load:s={},save:r={}}={},values:o={}}=e,i=u(R(b(Ra,o)),0,D(Ra)),c=i[2],w=P(c),y=P(c);return[0,n,[Da(s,{[$a]:null,[Ca]:U},$a,(a=>X(y,a)),(a=>_(w,a))),Da(r,{[Oa]:null,[Ca]:U,[ba]:0,[Ia]:0},Oa,((a,t)=>X(y,t)),((a,t)=>_(w,t))),i],w]})(n);return(S?ga:pa)(a,N,(a=>{let t;const e=()=>t=setInterval((async()=>{try{const[{d:t,s:e,c:n}]=await N(`${j} ${z} d,${G} s,TOTAL_CHANGES() c FROM ${k}${z} JOIN ${k}${G}`);t==p&&e==A&&n==h||(null!=p&&a(),p=t,A=e,h=n)}catch{}}),1e3*f),n=()=>{p=A=h=null,o(t)},s=r((t=>{T.has(t)&&(n(),a(),e())}));return e(),()=>{n(),i(s)}}),(a=>a()),w,y,d,m,Z(T),(async(a,t)=>await a(`${j} t.name tn,c.name cn FROM ${V}list()t,${V}info(t.name)c ${x} t.schema='main'AND t.type IN('table','view')AND t.name IN(${Q(t)})ORDER BY t.name,c.name`,t)),E,v,e,g,(a=>!0===a?1:!1===a?0:a),void 0)},Pa=async(a,t,e,s,r,o)=>{const i=[1],c=P(s),l=o?h([...o],(a=>a!=e&&!X(c,a))):[];if(!A(l)){const n=C(r),s=O(p(await a("SELECT"+K(e,...l)+"FROM"+W(t)+"WHERE"+W(e)+"IN("+Q(n)+")",n),(a=>[a[e],a])));v(n,(a=>N(r[a],...p(l,(t=>s?.[a]?.[t]??null)))))}await a("INSERT OR REPLACE INTO"+W(t)+"("+K(e,...s,...l)+")VALUES"+g(L(r,(a=>"($"+i[0]+++","+Q(a,i)+")")),n),L(r,((a,t)=>[t,...p(a,(a=>a??null))])).flat())};exports.createPowerSyncPersister=(a,t,e,n,s)=>{let r;return Ma(a,e,(async(a,e=[])=>t.execute(a,e).then((a=>a.rows?._array??[]))),(a=>{const e=new AbortController,n=t.onChange({rawTableNames:!0,signal:e.signal});return(async()=>{for await(const a of n)r&&p(a.changedTables,r)})(),r=a,e}),(a=>{r=void 0,a.abort()}),n,s,(()=>0),1,t,"getPowerSync",Pa)};
