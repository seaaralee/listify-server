"use strict";const t=t=>typeof t,a="tinybase",e=",",n=t(""),s=Promise,i=t=>null==t,r=(t,a,e)=>i(t)?e?.():a(t),o=a=>t(a)==n,c=t=>Array.isArray(t),E=(t,a,e)=>t.slice(a,e),l=t=>t.length,w=async t=>s.all(t),y=t=>{throw Error(t)},u=(t,a)=>t.forEach(a),d=(t,a="")=>t.join(a),T=(t,a)=>t.map(a),R=t=>0==l(t),A=(t,a)=>t.filter(a),N=(t,...a)=>t.push(...a),g=t=>t.shift(),p="_",C="_id",O="SELECT",L="WHERE",v="TABLE",$="ALTER "+v,S="DELETE FROM",I=O+"*FROM",m=t=>`"${t.replace(/"/g,'""')}"`,_=(t,a=[1])=>d(T(t,(()=>"$"+a[0]++)),e),h=(t,a)=>t?.has(a)??!1,f=t=>i(t)||0==(t=>t?.size??0)(t),b=t=>[...t?.values()??[]],P=(t,a)=>t?.forEach(a),D=(t,a)=>t?.delete(a),U=Object,F=t=>U.getPrototypeOf(t),M=U.entries,G=U.keys,B=U.freeze,j=(t=[])=>U.fromEntries(t),x=(...t)=>U.assign({},...t),X=(t,a)=>(delete t[a],t),Y=(t,a)=>T(M(t),(([t,e])=>a(e,t))),q=t=>U.values(t),H=t=>l(G(t)),W=t=>(t=>!i(t)&&r(F(t),(t=>t==U.prototype||i(F(t))),(()=>!0)))(t)&&0==H(t),k=JSON.stringify,z=JSON.parse,J=t=>new Map(t),K=(t,a)=>t?.get(a),V=(t,a)=>T([...t?.entries()??[]],(([t,e])=>a(e,t))),Q=(t,a,e)=>i(e)?(D(t,a),t):t?.set(a,e),Z=(t,a,e,n)=>(h(t,a)?n?.(K(t,a)):Q(t,a,e()),K(t,a)),tt=(t,a,e,n,s=0)=>r((e?Z:K)(t,a[s],s>l(a)-2?e:J),(i=>{if(s>l(a)-2)return n?.(i)&&Q(t,a[s]),i;const r=tt(i,a,e,n,s+1);return f(i)&&Q(t,a[s]),r})),at=t=>new Set(c(t)||i(t)?t:[t]),et=(t,a)=>t?.add(a),nt=/^\d+$/,st=J(),it=J(),rt=(t,a,e,n,s,o,E,w={},d=0,T=[])=>{let R,A,p,C=0,O=0,L=0;Z(st,T,(()=>0)),Z(it,T,(()=>[]));const v=J(),[$,S,I,m,_]=((t=1,a,e)=>1!=t&&a.isMergeable()?[1,a.getMergeableContent,()=>a.getTransactionMergeableChanges(!e),([[t],[a]])=>!W(t)||!W(a),a.setDefaultContent]:2!=t?[0,a.getContent,a.getTransactionChanges,([t,a])=>!W(t)||!W(a),a.setContent]:y("Store type not supported by this Persister"))(E,t,d),[h,b,U]=(()=>{let t;const[a,e]=(()=>{const t=[];let a=0;return[e=>(e?g(t):null)??""+a++,a=>{nt.test(a)&&l(t)<1e3&&N(t,a)}]})(),n=J();return[(e,s,i,r=[],o=()=>[])=>{t??=q;const c=a(1);return Q(n,c,[e,s,i,r,o]),et(tt(s,i??[""],at),c),c},(a,e,...s)=>u(((t,a=[""])=>{const e=[],n=(t,s)=>s==l(a)?N(e,t):null===a[s]?P(t,(t=>n(t,s+1))):u([a[s],null],(a=>n(K(t,a),s+1)));return n(t,0),e})(a,e),(a=>P(a,(a=>K(n,a)[0](t,...e??[],...s))))),t=>r(K(n,t),(([,a,s])=>(tt(a,s??[""],void 0,(a=>(D(a,t),f(a)?1:0))),Q(n,t),e(t),s))),a=>r(K(n,a),(([a,,e=[],n,s])=>{const r=(...o)=>{const c=l(o);c==l(e)?a(t,...o,...s(o)):i(e[c])?u(n[c]?.(...o)??[],(t=>r(...o,t))):r(...o,e[c])};r()}))]})(),F=t=>{t!=C&&(C=t,b(v,void 0,C))},M=a=>{($&&c(a?.[0])?1===a?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===a?.[2]?t.applyChanges:t.setContent)(a)},G=async t=>(2!=C&&(F(1),O++,await Y((async()=>{try{const e=await a();c(e)?M(e):t?_(t):y("Content is not an array: "+e)}catch(a){o?.(a),t&&_(t)}F(0)}))),q),j=()=>(A&&(s(A),A=void 0),q),x=async t=>(1!=C&&(F(2),L++,await Y((async()=>{try{await e(S,t)}catch(t){o?.(t)}F(0)}))),q),X=()=>(p&&(t.delListener(p),p=void 0),q),Y=async(...t)=>(N(K(it,T),...t),await(async()=>{if(!K(st,T)){for(Q(st,T,1);!i(R=g(K(it,T)));)try{await R()}catch(t){o?.(t)}Q(st,T,0)}})(),q),q={load:G,startAutoLoad:async t=>{j(),await G(t);try{A=await n((async(t,a)=>{a||t?2!=C&&(F(1),O++,M(a??t),F(0)):await G()}))}catch(t){o?.(t)}return q},stopAutoLoad:j,isAutoLoading:()=>!i(A),save:x,startAutoSave:async()=>(X(),await x(),p=t.addDidFinishTransactionListener((()=>{const t=I();m(t)&&x(t)})),q),stopAutoSave:X,isAutoSaving:()=>!i(p),getStatus:()=>C,addStatusListener:t=>h(t,v),delListener:a=>(U(a),t),schedule:Y,getStore:()=>t,destroy:()=>(K(it,T).splice(0,void 0),j().stopAutoSave()),getStats:()=>({loads:O,saves:L}),...w};return B(q)},ot=(t,a,n,s,r,o=ct,c,E)=>{const l=J();return[async()=>{l.clear(),T(await n(t,a),(({tn:t,cn:a})=>et(Z(l,t,at),a)))},async(a,e)=>((t,a)=>h(K(l,t),a))(a,e)?j(A(T(await t(I+m(a)),(t=>{return[t[e],E?(a=X(t,e),n=E,j(Y(a,((t,a)=>[a,n(t,a)])))):X(t,e)];var a,n})),(([t,a])=>!i(t)&&!W(a)))):{},async(a,n,s,E,y,u=!1)=>{const g=at();Y(s??{},(t=>T(G(t??{}),(t=>et(g,t)))));const p=b(g);if(!u&&y&&R(p)&&h(l,a))return await t("DROP "+v+m(a)),void Q(l,a);const C=K(l,a),O=at(b(C));if(R(p)||(h(l,a)?await w(T([n,...p],(async(e,s)=>{D(O,e)||(await t($+m(a)+"ADD"+m(e)+r),0==s&&await t("CREATE UNIQUE INDEX pk ON "+m(a)+`(${m(n)})`),et(C,e))}))):(await t("CREATE "+v+m(a)+`(${m(n)}${r} PRIMARY KEY${d(T(p,(t=>e+m(t)+r)))});`),Q(l,a,at([n,...p])))),await w([...!u&&E?T(b(O),(async e=>{e!=n&&(await t($+m(a)+"DROP"+m(e)),D(C,e))})):[]]),u)i(s)?await t(S+m(a)+L+" true"):await w(Y(s,(async(e,s)=>{i(e)?await t(S+m(a)+L+m(n)+"=$1",[s]):R(p)||await o(t,a,n,G(e),{[s]:c?T(q(e),c):q(e)},C)})));else if(R(p))h(l,a)&&await t(S+m(a)+L+" true");else{const e=A(b(K(l,a)),(t=>t!=n)),i={},r=[];Y(s??{},((t,a)=>{i[a]=T(e,(a=>c?c(t?.[a]):t?.[a])),N(r,a)})),await o(t,a,n,e,i),await t(S+m(a)+L+m(n)+`NOT IN(${_(r)})`,r)}},async a=>{let e;await t("BEGIN");try{e=await a()}catch(t){s?.(t)}return await t("END"),e}]},ct=async(t,a,n,s,i)=>{const r=[1];await t("INSERT INTO"+m(a)+"("+((...t)=>d(T(t,m),e))(n,...s)+")VALUES"+d(Y(i,(t=>"($"+r[0]+++","+_(t,r)+")")),e)+"ON CONFLICT("+m(n)+")DO UPDATE SET"+d(T(s,(t=>m(t)+"=excluded."+m(t))),e),Y(i,((t,a)=>[a,...T(t,(t=>t??null))])).flat())},Et=(t,a,e,n,s,i,r,[o,c,E],l,w,y,u,d,T)=>{const[R,A,N,g]=ot(a,l,w,s,d,T),C=rt(t,(async()=>await g((async()=>{return await R(),t=(await A(o,c))[p]?.[E]??"null",z(t,((t,a)=>"ï¿¼"===a?void 0:a));var t}))),(async t=>await g((async()=>{var a;await R(),await N(o,c,{[p]:{[E]:(a=t()??null,k(a,((t,a)=>void 0===a?"ï¿¼":a)))}},!0,!0)}))),e,n,s,r,{[u]:()=>y,destroy:()=>(C.stopAutoLoad().stopAutoSave(),i(),C)},0,y);return C},lt=(t,a,e,n,s,r,o,[c,E,[l,y,u]],d,T,R,N,g,O,L,v)=>{const[$,S,I,m]=ot(a,d,T,s,g,O,L,v),_=async(t,a)=>await w(V(E,(async([e,n,s,i],r)=>{a&&!(r in t)||await I(e,n,t[r],s,i,a)}))),h=async(t,a)=>y?await I(u,C,{[p]:t},!0,!0,a):null,f=rt(t,(async()=>await m((async()=>{await $();const t=await(async()=>j(A(await w(V(c,(async([t,a],e)=>[t,await S(e,a)]))),(t=>!W(t[1])))))(),a=await(async()=>l?(await S(u,C))[p]:{})();return W(t)&&i(a)?void 0:[t,a]}))),(async(t,a)=>await m((async()=>{if(await $(),i(a)){const[a,e]=t();await _(a),await h(e)}else await _(a[0],!0),await h(a[1],!0)}))),e,n,s,o,{[N]:()=>R,destroy:()=>(f.stopAutoLoad().stopAutoSave(),r(),f)},0,R);return f},wt="ColumnName",yt="store",ut="json",dt=yt+"TableName",Tt=yt+"Id"+wt,Rt=yt+wt,At="autoLoadIntervalSeconds",Nt="rowId"+wt,gt="tableId",pt="tableName",Ct="deleteEmptyColumns",Ot="deleteEmptyTable",Lt={mode:ut,[At]:1},vt={load:0,save:0,[pt]:a+"_values"},$t=(t,a,e,n,s)=>{const r=J();return Y(t,((t,c)=>{const l=E(q(x(a,o(t)?{[e]:t}:t)),0,H(a));i(l[0])||n(c,l[0])||(s(c,l[0]),Q(r,c,l))})),r},St=a,It=/^([cd]:)(.+)/,mt=a+"_data",_t=a+"_table";exports.createPostgresPersister=async(t,e,n,s,i)=>{const c=await(e.reserve?.());return((t,e,n,s,i,c,l,y,u,d,R="getDb")=>{const A=((t,a)=>a?async(e,n)=>(a(e,n),await t(e,n)):t)(n,c),[N,,g,p]=(t=>{const e=(t=>x(Lt,o(t)?{[dt]:t}:t??{}))(t),n=e[At];if(e.mode==ut){const t=e[dt]??a;return[1,n,[t,e[Tt]??C,e[Rt]??yt],at(t)]}const{tables:{load:s={},save:i={}}={},values:r={}}=e,c=E(q(x(vt,r)),0,H(vt)),l=c[2],w=at(l),y=at(l);return[0,n,[$t(s,{[gt]:null,[Nt]:C},gt,(t=>h(y,t)),(t=>et(w,t))),$t(i,{[pt]:null,[Nt]:C,[Ct]:0,[Ot]:0},pt,((t,a)=>h(y,a)),((t,a)=>et(w,a))),c],w]})(e),v=async t=>{await A(`CREATE OR REPLACE TRIGGER ${m(mt+"_"+t)} AFTER INSERT OR UPDATE OR DELETE ON ${m(t)} EXECUTE FUNCTION ${mt}()`)};return(N?Et:lt)(t,A,(async t=>{await A(`CREATE OR REPLACE FUNCTION ${_t}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${St}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await A(`CREATE EVENT TRIGGER ${_t} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${_t}();`)}catch{}return await A(`CREATE OR REPLACE FUNCTION ${mt}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${St}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await w(T(b(p),(async t=>{await A(`CREATE TABLE IF NOT EXISTS ${m(t)}("_id"text PRIMARY KEY)`),await v(t)}))),await s(St,(async a=>{return await r((e=a,n=It,e?.match(n)),(async([,a,e])=>{h(p,e)&&("c:"==a&&await v(e),t())}));var e,n}))}),i,l,y,u,g,b(p),(async(t,a)=>await t(`${O} table_name tn,column_name cn FROM information_schema.columns ${L} table_schema='public'AND table_name IN(${_(a)})`,a)),d,R,"text",void 0,(t=>k(t)),(t=>z(t)))})(t,n,c?.unsafe,(async(t,a)=>e.listen(t,a)),(async t=>{try{await t.unlisten()}catch(t){i?.(t)}}),s,i,(()=>c?.release?.()),3,e,"getSql")};
