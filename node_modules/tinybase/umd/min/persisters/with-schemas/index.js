var t,a;t=this,a=function(t){"use strict";const a=t=>typeof t,e="tinybase",n="",s=",",i=a(n),r=Promise,o=clearInterval,c=t=>null==t,l=(t,a,e)=>c(t)?e?.():a(t),E=t=>a(t)==i,d=t=>Array.isArray(t),y=(t,a,e)=>t.slice(a,e),u=t=>t.length,w=async t=>r.all(t),T=t=>{throw Error(t)},R=(t,a)=>t.forEach(a),A=(t,a="")=>t.join(a),N=(t,a)=>t.map(a),g=t=>0==u(t),p=(t,a)=>t.filter(a),m=(t,...a)=>t.push(...a),O=t=>t.shift(),$=Object,C=t=>$.getPrototypeOf(t),v=$.entries,S=$.keys,f=$.freeze,L=(t=[])=>$.fromEntries(t),I=(...t)=>$.assign({},...t),_=(t,a)=>(delete t[a],t),h=(t,a)=>N(v(t),(([t,e])=>a(e,t))),b=t=>$.values(t),P=t=>u(S(t)),D=t=>(t=>!c(t)&&l(C(t),(t=>t==$.prototype||c(C(t))),(()=>!0)))(t)&&0==P(t),M=(t,a)=>t?.has(a)??!1,F=t=>c(t)||0==(t=>t?.size??0)(t),U=t=>[...t?.values()??[]],G=(t,a)=>t?.forEach(a),B=(t,a)=>t?.delete(a),j=t=>new Map(t),x=(t,a)=>t?.get(a),Y=(t,a)=>N([...t?.entries()??[]],(([t,e])=>a(e,t))),q=(t,a,e)=>c(e)?(B(t,a),t):t?.set(a,e),H=(t,a,e,n)=>(M(t,a)?n?.(x(t,a)):q(t,a,e()),x(t,a)),X=(t,a,e,n,s=0)=>l((e?H:x)(t,a[s],s>u(a)-2?e:j),(i=>{if(s>u(a)-2)return n?.(i)&&q(t,a[s]),i;const r=X(i,a,e,n,s+1);return F(i)&&q(t,a[s]),r})),J=t=>new Set(d(t)||c(t)?t:[t]),W=(t,a)=>t?.add(a),k=/^\d+$/,z=j(),K=j(),V=(t,a,e,s,i,r,o,E={},y=0,w=[])=>{let A,N,g,p=0,$=0,C=0;H(z,w,(()=>0)),H(K,w,(()=>[]));const v=j(),[S,L,I,_,h]=((t=1,a,e)=>1!=t&&a.isMergeable()?[1,a.getMergeableContent,()=>a.getTransactionMergeableChanges(!e),([[t],[a]])=>!D(t)||!D(a),a.setDefaultContent]:2!=t?[0,a.getContent,a.getTransactionChanges,([t,a])=>!D(t)||!D(a),a.setContent]:T("Store type not supported by this Persister"))(o,t,y),[b,P,M]=(()=>{let t;const[a,e]=(()=>{const t=[];let a=0;return[e=>(e?O(t):null)??n+a++,a=>{k.test(a)&&u(t)<1e3&&m(t,a)}]})(),s=j();return[(e,i,r,o=[],c=()=>[])=>{t??=et;const l=a(1);return q(s,l,[e,i,r,o,c]),W(X(i,r??[n],J),l),l},(a,e,...i)=>R(((t,a=[n])=>{const e=[],s=(t,n)=>n==u(a)?m(e,t):null===a[n]?G(t,(t=>s(t,n+1))):R([a[n],null],(a=>s(x(t,a),n+1)));return s(t,0),e})(a,e),(a=>G(a,(a=>x(s,a)[0](t,...e??[],...i))))),t=>l(x(s,t),(([,a,i])=>(X(a,i??[n],void 0,(a=>(B(a,t),F(a)?1:0))),q(s,t),e(t),i))),a=>l(x(s,a),(([a,,e=[],n,s])=>{const i=(...r)=>{const o=u(r);o==u(e)?a(t,...r,...s(r)):c(e[o])?R(n[o]?.(...r)??[],(t=>i(...r,t))):i(...r,e[o])};i()}))]})(),U=t=>{t!=p&&(p=t,P(v,void 0,p))},Y=a=>{(S&&d(a?.[0])?1===a?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===a?.[2]?t.applyChanges:t.setContent)(a)},V=async t=>(2!=p&&(U(1),$++,await at((async()=>{try{const e=await a();d(e)?Y(e):t?h(t):T("Content is not an array: "+e)}catch(a){r?.(a),t&&h(t)}U(0)}))),et),Q=()=>(N&&(i(N),N=void 0),et),Z=async t=>(1!=p&&(U(2),C++,await at((async()=>{try{await e(L,t)}catch(t){r?.(t)}U(0)}))),et),tt=()=>(g&&(t.delListener(g),g=void 0),et),at=async(...t)=>(m(x(K,w),...t),await(async()=>{if(!x(z,w)){for(q(z,w,1);!c(A=O(x(K,w)));)try{await A()}catch(t){r?.(t)}q(z,w,0)}})(),et),et={load:V,startAutoLoad:async t=>{Q(),await V(t);try{N=await s((async(t,a)=>{a||t?2!=p&&(U(1),$++,Y(a??t),U(0)):await V()}))}catch(t){r?.(t)}return et},stopAutoLoad:Q,isAutoLoading:()=>!c(N),save:Z,startAutoSave:async()=>(tt(),await Z(),g=t.addDidFinishTransactionListener((()=>{const t=I();_(t)&&Z(t)})),et),stopAutoSave:tt,isAutoSaving:()=>!c(g),getStatus:()=>p,addStatusListener:t=>b(t,v),delListener:a=>(M(a),t),schedule:at,getStore:()=>t,destroy:()=>(x(K,w).splice(0,void 0),Q().stopAutoSave()),getStats:()=>({loads:$,saves:C}),...E};return f(et)},Q="_",Z="_id",tt="SELECT",at="WHERE",et="TABLE",nt="ALTER "+et,st="DELETE FROM",it=tt+"*FROM",rt="pragma_",ot="data_version",ct="schema_version",lt="pragma_table_",Et=(t,a)=>a?async(e,n)=>(a(e,n),await t(e,n)):t,dt=t=>`"${t.replace(/"/g,'""')}"`,yt=(t,a=[1])=>A(N(t,(()=>"$"+a[0]++)),s),ut=JSON.stringify,wt=JSON.parse,Tt=(t,a,e,n,i,r=Rt,o,l)=>{const E=j();return[async()=>{E.clear(),N(await e(t,a),(({tn:t,cn:a})=>W(H(E,t,J),a)))},async(a,e)=>((t,a)=>M(x(E,t),a))(a,e)?L(p(N(await t(it+dt(a)),(t=>{return[t[e],l?(a=_(t,e),n=l,L(h(a,((t,a)=>[a,n(t,a)])))):_(t,e)];var a,n})),(([t,a])=>!c(t)&&!D(a)))):{},async(a,e,n,l,d,y=!1)=>{const u=J();h(n??{},(t=>N(S(t??{}),(t=>W(u,t)))));const T=U(u);if(!y&&d&&g(T)&&M(E,a))return await t("DROP "+et+dt(a)),void q(E,a);const R=x(E,a),O=J(U(R));if(g(T)||(M(E,a)?await w(N([e,...T],(async(n,s)=>{B(O,n)||(await t(nt+dt(a)+"ADD"+dt(n)+i),0==s&&await t("CREATE UNIQUE INDEX pk ON "+dt(a)+`(${dt(e)})`),W(R,n))}))):(await t("CREATE "+et+dt(a)+`(${dt(e)}${i} PRIMARY KEY${A(N(T,(t=>s+dt(t)+i)))});`),q(E,a,J([e,...T])))),await w([...!y&&l?N(U(O),(async n=>{n!=e&&(await t(nt+dt(a)+"DROP"+dt(n)),B(R,n))})):[]]),y)c(n)?await t(st+dt(a)+at+" true"):await w(h(n,(async(n,s)=>{c(n)?await t(st+dt(a)+at+dt(e)+"=$1",[s]):g(T)||await r(t,a,e,S(n),{[s]:o?N(b(n),o):b(n)},R)})));else if(g(T))M(E,a)&&await t(st+dt(a)+at+" true");else{const s=p(U(x(E,a)),(t=>t!=e)),i={},c=[];h(n??{},((t,a)=>{i[a]=N(s,(a=>o?o(t?.[a]):t?.[a])),m(c,a)})),await r(t,a,e,s,i),await t(st+dt(a)+at+dt(e)+`NOT IN(${yt(c)})`,c)}},async a=>{let e;await t("BEGIN");try{e=await a()}catch(t){n?.(t)}return await t("END"),e}]},Rt=async(t,a,e,n,i)=>{const r=[1];await t("INSERT INTO"+dt(a)+"("+((...t)=>A(N(t,dt),s))(e,...n)+")VALUES"+A(h(i,(t=>"($"+r[0]+++","+yt(t,r)+")")),s)+"ON CONFLICT("+dt(e)+")DO UPDATE SET"+A(N(n,(t=>dt(t)+"=excluded."+dt(t))),s),h(i,((t,a)=>[a,...N(t,(t=>t??null))])).flat())},At=(t,a,e,n,s,i,r,[o,c,l],E,d,y,u,w,T)=>{const[R,A,N,g]=Tt(a,E,d,s,w,T),p=V(t,(async()=>await g((async()=>{return await R(),t=(await A(o,c))[Q]?.[l]??"null",wt(t,((t,a)=>"￼"===a?void 0:a));var t}))),(async t=>await g((async()=>{var a;await R(),await N(o,c,{[Q]:{[l]:(a=t()??null,ut(a,((t,a)=>void 0===a?"￼":a)))}},!0,!0)}))),e,n,s,r,{[u]:()=>y,destroy:()=>(p.stopAutoLoad().stopAutoSave(),i(),p)},0,y);return p},Nt=(t,a,e,n,s,i,r,[o,l,[E,d,y]],u,T,R,A,N,g,m,O)=>{const[$,C,v,S]=Tt(a,u,T,s,N,g,m,O),f=async(t,a)=>await w(Y(l,(async([e,n,s,i],r)=>{a&&!(r in t)||await v(e,n,t[r],s,i,a)}))),I=async(t,a)=>d?await v(y,Z,{[Q]:t},!0,!0,a):null,_=V(t,(async()=>await S((async()=>{await $();const t=await(async()=>L(p(await w(Y(o,(async([t,a],e)=>[t,await C(e,a)]))),(t=>!D(t[1])))))(),a=await(async()=>E?(await C(y,Z))[Q]:{})();return D(t)&&c(a)?void 0:[t,a]}))),(async(t,a)=>await S((async()=>{if(await $(),c(a)){const[a,e]=t();await f(a),await I(e)}else await f(a[0],!0),await I(a[1],!0)}))),e,n,s,r,{[A]:()=>R,destroy:()=>(_.stopAutoLoad().stopAutoSave(),i(),_)},0,R);return _},gt="ColumnName",pt="store",mt="json",Ot=pt+"TableName",$t=pt+"Id"+gt,Ct=pt+gt,vt="autoLoadIntervalSeconds",St="rowId"+gt,ft="tableId",Lt="tableName",It="deleteEmptyColumns",_t="deleteEmptyTable",ht={mode:mt,[vt]:1},bt={load:0,save:0,[Lt]:e+"_values"},Pt=(t,a,e,n,s)=>{const i=j();return h(t,((t,r)=>{const o=y(b(I(a,E(t)?{[e]:t}:t)),0,P(a));c(o[0])||n(r,o[0])||(s(r,o[0]),q(i,r,o))})),i},Dt=t=>{const a=(t=>I(ht,E(t)?{[Ot]:t}:t??{}))(t),n=a[vt];if(a.mode==mt){const t=a[Ot]??e;return[1,n,[t,a[$t]??Z,a[Ct]??pt],J(t)]}const{tables:{load:s={},save:i={}}={},values:r={}}=a,o=y(b(I(bt,r)),0,P(bt)),c=o[2],l=J(c),d=J(c);return[0,n,[Pt(s,{[ft]:null,[St]:Z},ft,(t=>M(d,t)),(t=>W(l,t))),Pt(i,{[Lt]:null,[St]:Z,[It]:0,[_t]:0},Lt,((t,a)=>M(d,a)),((t,a)=>W(l,a))),o],l]},Mt=e,Ft=/^([cd]:)(.+)/,Ut=e+"_data",Gt=e+"_table";t.Persists={StoreOnly:1,MergeableStoreOnly:2,StoreOrMergeableStore:3},t.Status={Idle:0,Loading:1,Saving:2},t.createCustomPersister=V,t.createCustomPostgreSqlPersister=(t,a,e,n,s,i,r,o,c,E,d="getDb")=>{const y=Et(e,i),[u,,T,R]=Dt(a),A=async t=>{await y(`CREATE OR REPLACE TRIGGER ${dt(Ut+"_"+t)} AFTER INSERT OR UPDATE OR DELETE ON ${dt(t)} EXECUTE FUNCTION ${Ut}()`)};return(u?At:Nt)(t,y,(async t=>{await y(`CREATE OR REPLACE FUNCTION ${Gt}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${Mt}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await y(`CREATE EVENT TRIGGER ${Gt} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${Gt}();`)}catch{}return await y(`CREATE OR REPLACE FUNCTION ${Ut}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${Mt}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await w(N(U(R),(async t=>{await y(`CREATE TABLE IF NOT EXISTS ${dt(t)}("_id"text PRIMARY KEY)`),await A(t)}))),await n(Mt,(async a=>{return await l((e=a,n=Ft,e?.match(n)),(async([,a,e])=>{M(R,e)&&("c:"==a&&await A(e),t())}));var e,n}))}),s,r,o,c,T,U(R),(async(t,a)=>await t(`${tt} table_name tn,column_name cn FROM information_schema.columns ${at} table_schema='public'AND table_name IN(${yt(a)})`,a)),E,d,"text",void 0,(t=>ut(t)),(t=>wt(t)))},t.createCustomSqlitePersister=(t,a,e,s,i,r,c,l,E,d,y="getDb",u)=>{let w,T,R;const A=Et(e,r),[N,g,p,m]=Dt(a);return(N?At:Nt)(t,A,(t=>{let a;const e=()=>a=setInterval((async()=>{try{const[{d:a,s:e,c:n}]=await A(`${tt} ${ot} d,${ct} s,TOTAL_CHANGES() c FROM ${rt}${ot} JOIN ${rt}${ct}`);a==w&&e==T&&n==R||(null!=w&&t(),w=a,T=e,R=n)}catch{}}),1e3*g),n=()=>{w=T=R=null,o(a)},r=s((a=>{m.has(a)&&(n(),t(),e())}));return e(),()=>{n(),i(r)}}),(t=>t()),c,l,E,p,U(m),(async(t,a)=>await t(`${tt} t.name tn,c.name cn FROM ${lt}list()t,${lt}info(t.name)c ${at} t.schema='main'AND t.type IN('table','view')AND t.name IN(${yt(a)})ORDER BY t.name,c.name`,a)),d,y,n,u,(t=>!0===t?1:!1===t?0:t),void 0)}},"object"==typeof exports&&"undefined"!=typeof module?a(exports):"function"==typeof define&&define.amd?define(["exports"],a):a((t="undefined"!=typeof globalThis?globalThis:t||self).TinyBasePersisters={});
