var t,a;t=this,a=function(t){"use strict";const a=t=>typeof t,e="tinybase",n=",",s=a(""),i=Promise,r=t=>null==t,o=(t,a,e)=>r(t)?e?.():a(t),c=t=>a(t)==s,l=t=>Array.isArray(t),E=(t,a,e)=>t.slice(a,e),y=t=>t.length,w=async t=>i.all(t),d=t=>{throw Error(t)},u=(t,a)=>t.forEach(a),T=(t,a="")=>t.join(a),R=(t,a)=>t.map(a),A=t=>0==y(t),N=(t,a)=>t.filter(a),g=(t,...a)=>t.push(...a),p=t=>t.shift(),C="_",f="_id",O="SELECT",v="WHERE",L="TABLE",$="ALTER "+L,m="DELETE FROM",S=O+"*FROM",I=t=>`"${t.replace(/"/g,'""')}"`,h=(t,a=[1])=>T(R(t,(()=>"$"+a[0]++)),n),_=(t,a)=>t?.has(a)??!1,b=t=>r(t)||0==(t=>t?.size??0)(t),P=t=>[...t?.values()??[]],D=(t,a)=>t?.forEach(a),U=(t,a)=>t?.delete(a),F=Object,M=t=>F.getPrototypeOf(t),G=F.entries,B=F.keys,j=F.freeze,x=(t=[])=>F.fromEntries(t),X=(...t)=>F.assign({},...t),Y=(t,a)=>(delete t[a],t),q=(t,a)=>R(G(t),(([t,e])=>a(e,t))),H=t=>F.values(t),W=t=>y(B(t)),k=t=>(t=>!r(t)&&o(M(t),(t=>t==F.prototype||r(M(t))),(()=>!0)))(t)&&0==W(t),z=JSON.stringify,J=JSON.parse,K=t=>new Map(t),V=(t,a)=>t?.get(a),Q=(t,a)=>R([...t?.entries()??[]],(([t,e])=>a(e,t))),Z=(t,a,e)=>r(e)?(U(t,a),t):t?.set(a,e),tt=(t,a,e,n)=>(_(t,a)?n?.(V(t,a)):Z(t,a,e()),V(t,a)),at=(t,a,e,n,s=0)=>o((e?tt:V)(t,a[s],s>y(a)-2?e:K),(i=>{if(s>y(a)-2)return n?.(i)&&Z(t,a[s]),i;const r=at(i,a,e,n,s+1);return b(i)&&Z(t,a[s]),r})),et=t=>new Set(l(t)||r(t)?t:[t]),nt=(t,a)=>t?.add(a),st=/^\d+$/,it=K(),rt=K(),ot=(t,a,e,n,s,i,c,E={},w=0,T=[])=>{let R,A,N,C=0,f=0,O=0;tt(it,T,(()=>0)),tt(rt,T,(()=>[]));const v=K(),[L,$,m,S,I]=((t=1,a,e)=>1!=t&&a.isMergeable()?[1,a.getMergeableContent,()=>a.getTransactionMergeableChanges(!e),([[t],[a]])=>!k(t)||!k(a),a.setDefaultContent]:2!=t?[0,a.getContent,a.getTransactionChanges,([t,a])=>!k(t)||!k(a),a.setContent]:d("Store type not supported by this Persister"))(c,t,w),[h,_,P]=(()=>{let t;const[a,e]=(()=>{const t=[];let a=0;return[e=>(e?p(t):null)??""+a++,a=>{st.test(a)&&y(t)<1e3&&g(t,a)}]})(),n=K();return[(e,s,i,r=[],o=()=>[])=>{t??=q;const c=a(1);return Z(n,c,[e,s,i,r,o]),nt(at(s,i??[""],et),c),c},(a,e,...s)=>u(((t,a=[""])=>{const e=[],n=(t,s)=>s==y(a)?g(e,t):null===a[s]?D(t,(t=>n(t,s+1))):u([a[s],null],(a=>n(V(t,a),s+1)));return n(t,0),e})(a,e),(a=>D(a,(a=>V(n,a)[0](t,...e??[],...s))))),t=>o(V(n,t),(([,a,s])=>(at(a,s??[""],void 0,(a=>(U(a,t),b(a)?1:0))),Z(n,t),e(t),s))),a=>o(V(n,a),(([a,,e=[],n,s])=>{const i=(...o)=>{const c=y(o);c==y(e)?a(t,...o,...s(o)):r(e[c])?u(n[c]?.(...o)??[],(t=>i(...o,t))):i(...o,e[c])};i()}))]})(),F=t=>{t!=C&&(C=t,_(v,void 0,C))},M=a=>{(L&&l(a?.[0])?1===a?.[2]?t.applyMergeableChanges:t.setMergeableContent:1===a?.[2]?t.applyChanges:t.setContent)(a)},G=async t=>(2!=C&&(F(1),f++,await Y((async()=>{try{const e=await a();l(e)?M(e):t?I(t):d("Content is not an array: "+e)}catch(a){i?.(a),t&&I(t)}F(0)}))),q),B=()=>(A&&(s(A),A=void 0),q),x=async t=>(1!=C&&(F(2),O++,await Y((async()=>{try{await e($,t)}catch(t){i?.(t)}F(0)}))),q),X=()=>(N&&(t.delListener(N),N=void 0),q),Y=async(...t)=>(g(V(rt,T),...t),await(async()=>{if(!V(it,T)){for(Z(it,T,1);!r(R=p(V(rt,T)));)try{await R()}catch(t){i?.(t)}Z(it,T,0)}})(),q),q={load:G,startAutoLoad:async t=>{B(),await G(t);try{A=await n((async(t,a)=>{a||t?2!=C&&(F(1),f++,M(a??t),F(0)):await G()}))}catch(t){i?.(t)}return q},stopAutoLoad:B,isAutoLoading:()=>!r(A),save:x,startAutoSave:async()=>(X(),await x(),N=t.addDidFinishTransactionListener((()=>{const t=m();S(t)&&x(t)})),q),stopAutoSave:X,isAutoSaving:()=>!r(N),getStatus:()=>C,addStatusListener:t=>h(t,v),delListener:a=>(P(a),t),schedule:Y,getStore:()=>t,destroy:()=>(V(rt,T).splice(0,void 0),B().stopAutoSave()),getStats:()=>({loads:f,saves:O}),...E};return j(q)},ct=(t,a,e,s,i,o=lt,c,l)=>{const E=K();return[async()=>{E.clear(),R(await e(t,a),(({tn:t,cn:a})=>nt(tt(E,t,et),a)))},async(a,e)=>((t,a)=>_(V(E,t),a))(a,e)?x(N(R(await t(S+I(a)),(t=>{return[t[e],l?(a=Y(t,e),n=l,x(q(a,((t,a)=>[a,n(t,a)])))):Y(t,e)];var a,n})),(([t,a])=>!r(t)&&!k(a)))):{},async(a,e,s,l,y,d=!1)=>{const u=et();q(s??{},(t=>R(B(t??{}),(t=>nt(u,t)))));const p=P(u);if(!d&&y&&A(p)&&_(E,a))return await t("DROP "+L+I(a)),void Z(E,a);const C=V(E,a),f=et(P(C));if(A(p)||(_(E,a)?await w(R([e,...p],(async(n,s)=>{U(f,n)||(await t($+I(a)+"ADD"+I(n)+i),0==s&&await t("CREATE UNIQUE INDEX pk ON "+I(a)+`(${I(e)})`),nt(C,n))}))):(await t("CREATE "+L+I(a)+`(${I(e)}${i} PRIMARY KEY${T(R(p,(t=>n+I(t)+i)))});`),Z(E,a,et([e,...p])))),await w([...!d&&l?R(P(f),(async n=>{n!=e&&(await t($+I(a)+"DROP"+I(n)),U(C,n))})):[]]),d)r(s)?await t(m+I(a)+v+" true"):await w(q(s,(async(n,s)=>{r(n)?await t(m+I(a)+v+I(e)+"=$1",[s]):A(p)||await o(t,a,e,B(n),{[s]:c?R(H(n),c):H(n)},C)})));else if(A(p))_(E,a)&&await t(m+I(a)+v+" true");else{const n=N(P(V(E,a)),(t=>t!=e)),i={},r=[];q(s??{},((t,a)=>{i[a]=R(n,(a=>c?c(t?.[a]):t?.[a])),g(r,a)})),await o(t,a,e,n,i),await t(m+I(a)+v+I(e)+`NOT IN(${h(r)})`,r)}},async a=>{let e;await t("BEGIN");try{e=await a()}catch(t){s?.(t)}return await t("END"),e}]},lt=async(t,a,e,s,i)=>{const r=[1];await t("INSERT INTO"+I(a)+"("+((...t)=>T(R(t,I),n))(e,...s)+")VALUES"+T(q(i,(t=>"($"+r[0]+++","+h(t,r)+")")),n)+"ON CONFLICT("+I(e)+")DO UPDATE SET"+T(R(s,(t=>I(t)+"=excluded."+I(t))),n),q(i,((t,a)=>[a,...R(t,(t=>t??null))])).flat())},Et=(t,a,e,n,s,i,r,[o,c,l],E,y,w,d,u,T)=>{const[R,A,N,g]=ct(a,E,y,s,u,T),p=ot(t,(async()=>await g((async()=>{return await R(),t=(await A(o,c))[C]?.[l]??"null",J(t,((t,a)=>"￼"===a?void 0:a));var t}))),(async t=>await g((async()=>{var a;await R(),await N(o,c,{[C]:{[l]:(a=t()??null,z(a,((t,a)=>void 0===a?"￼":a)))}},!0,!0)}))),e,n,s,r,{[d]:()=>w,destroy:()=>(p.stopAutoLoad().stopAutoSave(),i(),p)},0,w);return p},yt=(t,a,e,n,s,i,o,[c,l,[E,y,d]],u,T,R,A,g,p,O,v)=>{const[L,$,m,S]=ct(a,u,T,s,g,p,O,v),I=async(t,a)=>await w(Q(l,(async([e,n,s,i],r)=>{a&&!(r in t)||await m(e,n,t[r],s,i,a)}))),h=async(t,a)=>y?await m(d,f,{[C]:t},!0,!0,a):null,_=ot(t,(async()=>await S((async()=>{await L();const t=await(async()=>x(N(await w(Q(c,(async([t,a],e)=>[t,await $(e,a)]))),(t=>!k(t[1])))))(),a=await(async()=>E?(await $(d,f))[C]:{})();return k(t)&&r(a)?void 0:[t,a]}))),(async(t,a)=>await S((async()=>{if(await L(),r(a)){const[a,e]=t();await I(a),await h(e)}else await I(a[0],!0),await h(a[1],!0)}))),e,n,s,o,{[A]:()=>R,destroy:()=>(_.stopAutoLoad().stopAutoSave(),i(),_)},0,R);return _},wt="ColumnName",dt="store",ut="json",Tt=dt+"TableName",Rt=dt+"Id"+wt,At=dt+wt,Nt="autoLoadIntervalSeconds",gt="rowId"+wt,pt="tableId",Ct="tableName",ft="deleteEmptyColumns",Ot="deleteEmptyTable",vt={mode:ut,[Nt]:1},Lt={load:0,save:0,[Ct]:e+"_values"},$t=(t,a,e,n,s)=>{const i=K();return q(t,((t,o)=>{const l=E(H(X(a,c(t)?{[e]:t}:t)),0,W(a));r(l[0])||n(o,l[0])||(s(o,l[0]),Z(i,o,l))})),i},mt=e,St=/^([cd]:)(.+)/,It=e+"_data",ht=e+"_table";t.createPostgresPersister=async(t,a,n,s,i)=>{const r=await(a.reserve?.());return((t,a,n,s,i,r,l,y,d,u,T="getDb")=>{const A=((t,a)=>a?async(e,n)=>(a(e,n),await t(e,n)):t)(n,r),[N,,g,p]=(t=>{const a=(t=>X(vt,c(t)?{[Tt]:t}:t??{}))(t),n=a[Nt];if(a.mode==ut){const t=a[Tt]??e;return[1,n,[t,a[Rt]??f,a[At]??dt],et(t)]}const{tables:{load:s={},save:i={}}={},values:r={}}=a,o=E(H(X(Lt,r)),0,W(Lt)),l=o[2],y=et(l),w=et(l);return[0,n,[$t(s,{[pt]:null,[gt]:f},pt,(t=>_(w,t)),(t=>nt(y,t))),$t(i,{[Ct]:null,[gt]:f,[ft]:0,[Ot]:0},Ct,((t,a)=>_(w,a)),((t,a)=>nt(y,a))),o],y]})(a),C=async t=>{await A(`CREATE OR REPLACE TRIGGER ${I(It+"_"+t)} AFTER INSERT OR UPDATE OR DELETE ON ${I(t)} EXECUTE FUNCTION ${It}()`)};return(N?Et:yt)(t,A,(async t=>{await A(`CREATE OR REPLACE FUNCTION ${ht}()RETURNS event_trigger AS $t2$ DECLARE row record; BEGIN FOR row IN SELECT object_identity FROM pg_event_trigger_ddl_commands()WHERE command_tag='CREATE TABLE' LOOP PERFORM pg_notify('${mt}','c:'||SPLIT_PART(row.object_identity,'.',2));END LOOP;END;$t2$ LANGUAGE plpgsql;`);try{await A(`CREATE EVENT TRIGGER ${ht} ON ddl_command_end WHEN TAG IN('CREATE TABLE')EXECUTE FUNCTION ${ht}();`)}catch{}return await A(`CREATE OR REPLACE FUNCTION ${It}()RETURNS trigger AS $t1$ BEGIN PERFORM pg_notify('${mt}','d:'||TG_TABLE_NAME);RETURN NULL;END;$t1$ LANGUAGE plpgsql;`),await w(R(P(p),(async t=>{await A(`CREATE TABLE IF NOT EXISTS ${I(t)}("_id"text PRIMARY KEY)`),await C(t)}))),await s(mt,(async a=>{return await o((e=a,n=St,e?.match(n)),(async([,a,e])=>{_(p,e)&&("c:"==a&&await C(e),t())}));var e,n}))}),i,l,y,d,g,P(p),(async(t,a)=>await t(`${O} table_name tn,column_name cn FROM information_schema.columns ${v} table_schema='public'AND table_name IN(${h(a)})`,a)),u,T,"text",void 0,(t=>z(t)),(t=>J(t)))})(t,n,r?.unsafe,(async(t,e)=>a.listen(t,e)),(async t=>{try{await t.unlisten()}catch(t){i?.(t)}}),s,i,(()=>r?.release?.()),3,a,"getSql")}},"object"==typeof exports&&"undefined"!=typeof module?a(exports):"function"==typeof define&&define.amd?define(["exports"],a):a((t="undefined"!=typeof globalThis?globalThis:t||self).TinyBasePersisterPostgres={});
